"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:no-bitwise */
var typescript_1 = require("typescript");
var getDecorators_1 = require("../services/TsParser/getDecorators");
var getTypeText_1 = require("../services/TsParser/getTypeText");
var ContainerExportDoc_1 = require("./ContainerExportDoc");
/**
 * Interfaces and classes are "class-like", in that they can contain members, heritage, type parameters and decorators
 */
var ClassLikeExportDoc = (function (_super) {
    __extends(ClassLikeExportDoc, _super);
    function ClassLikeExportDoc(moduleDoc, symbol, declaration, basePath, namespacesToInclude) {
        var _this = _super.call(this, moduleDoc, symbol, declaration, basePath, namespacesToInclude) || this;
        _this.decorators = getDecorators_1.getDecorators(_this.declaration);
        _this.extendsClauses = [];
        _this.implementsClauses = [];
        _this.typeParams = _this.computeTypeParams();
        _this.computeHeritage();
        _this.addAliases();
        return _this;
    }
    ClassLikeExportDoc.prototype.computeTypeParams = function () {
        if (this.symbol.members) {
            var typeParams_1 = [];
            this.symbol.members.forEach(function (member, name) {
                if (member.getFlags() & typescript_1.SymbolFlags.TypeParameter) {
                    typeParams_1.push(name);
                }
            });
            if (typeParams_1.length)
                return "<" + typeParams_1.join(', ') + ">";
        }
        return '';
    };
    ClassLikeExportDoc.prototype.addAliases = function () {
        if (this.typeParams) {
            // Make sure duplicate aliases aren't created, so "Ambiguous link" warnings are prevented
            this.aliases.push(this.name + this.typeParams);
            this.aliases.push(this.moduleDoc.id + '/' + this.name + this.typeParams);
        }
    };
    ClassLikeExportDoc.prototype.computeHeritage = function () {
        var _this = this;
        // Collect up all the heritage clauses from each declarartion
        // (interfaces can have multiple declarations, which are merged, each with their own heritage)
        this.symbol.getDeclarations().forEach(function (declaration) {
            var heritageClauses = getHeritage(declaration);
            if (heritageClauses) {
                heritageClauses.forEach(function (heritageClause) {
                    if (heritageClause.token === typescript_1.SyntaxKind.ExtendsKeyword) {
                        _this.extendsClauses = _this.extendsClauses.concat(heritageClause.types.map(function (heritageType) { return getTypeText_1.getTypeText(heritageType, _this.namespacesToInclude); }));
                    }
                    else {
                        _this.implementsClauses = _this.implementsClauses.concat(heritageClause.types.map(function (heritageType) { return getTypeText_1.getTypeText(heritageType, _this.namespacesToInclude); }));
                    }
                });
            }
        });
    };
    return ClassLikeExportDoc;
}(ContainerExportDoc_1.ContainerExportDoc));
exports.ClassLikeExportDoc = ClassLikeExportDoc;
function getHeritage(declaration) {
    return declaration.heritageClauses;
}
//# sourceMappingURL=ClassLikeExportDoc.js.map