{"version":3,"sources":["../../../../src/cdk/a11y/list-key-manager.ts"],"names":[],"mappings":"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","file":"list-key-manager.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {QueryList} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {Subject} from 'rxjs/Subject';\nimport {UP_ARROW, DOWN_ARROW, TAB} from '@angular/cdk/keyboard';\n\n/**\n * This interface is for items that can be disabled. The type passed into\n * ListKeyManager must extend this interface.\n */\nexport interface CanDisable {\n  disabled?: boolean;\n}\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nexport class ListKeyManager<T extends CanDisable> {\nprivate _activeItemIndex: number = -1;\nprivate _activeItem: T;\nprivate _tabOut = new Subject<void>();\nprivate _wrap: boolean = false;\n/**\n * @param {?} _items\n */\nconstructor(private _items: QueryList<T>) { }\n/**\n * Turns on wrapping mode, which ensures that the active item will wrap to\n * the other end of list when there are no more items in the given direction.\n * \n * @return {?} The ListKeyManager that the method was called on.\n */\nwithWrap(): this {\n    this._wrap = true;\n    return this;\n  }\n/**\n * Sets the active item to the item at the index specified.\n * \n * @param {?} index The index of the item to be set as active.\n * @return {?}\n */\nsetActiveItem(index: number): void {\n    this._activeItemIndex = index;\n    this._activeItem = this._items.toArray()[index];\n  }\n/**\n * Sets the active item depending on the key event passed in.\n * @param {?} event Keyboard event to be used for determining which element should be active.\n * @return {?}\n */\nonKeydown(event: KeyboardEvent): void {\n    switch (event.keyCode) {\n      case DOWN_ARROW:\n        this.setNextItemActive();\n        break;\n      case UP_ARROW:\n        this.setPreviousItemActive();\n        break;\n      case TAB:\n        // Note that we shouldn't prevent the default action on tab.\n        this._tabOut.next();\n        return;\n      default:\n        return;\n    }\n\n    event.preventDefault();\n  }\n/**\n * Index of the currently active item.\n * @return {?}\n */\nget activeItemIndex(): number | null {\n    return this._activeItemIndex;\n  }\n/**\n * The active item.\n * @return {?}\n */\nget activeItem(): T | null {\n    return this._activeItem;\n  }\n/**\n * Sets the active item to the first enabled item in the list.\n * @return {?}\n */\nsetFirstItemActive(): void {\n    this._setActiveItemByIndex(0, 1);\n  }\n/**\n * Sets the active item to the last enabled item in the list.\n * @return {?}\n */\nsetLastItemActive(): void {\n    this._setActiveItemByIndex(this._items.length - 1, -1);\n  }\n/**\n * Sets the active item to the next enabled item in the list.\n * @return {?}\n */\nsetNextItemActive(): void {\n    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n  }\n/**\n * Sets the active item to a previous enabled item in the list.\n * @return {?}\n */\nsetPreviousItemActive(): void {\n    this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n                                            : this._setActiveItemByDelta(-1);\n  }\n/**\n * Allows setting of the activeItemIndex without any other effects.\n * @param {?} index The new activeItemIndex.\n * @return {?}\n */\nupdateActiveItemIndex(index: number) {\n    this._activeItemIndex = index;\n  }\n/**\n * Observable that emits any time the TAB key is pressed, so components can react\n * when focus is shifted off of the list.\n * @return {?}\n */\nget tabOut(): Observable<void> {\n    return this._tabOut.asObservable();\n  }\n/**\n * This method sets the active item, given a list of items and the delta between the\n * currently active item and the new active item. It will calculate differently\n * depending on whether wrap mode is turned on.\n * @param {?} delta\n * @param {?=} items\n * @return {?}\n */\nprivate _setActiveItemByDelta(delta: number, items = this._items.toArray()): void {\n    this._wrap ? this._setActiveInWrapMode(delta, items)\n               : this._setActiveInDefaultMode(delta, items);\n  }\n/**\n * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n * down the list until it finds an item that is not disabled, and it will wrap if it\n * encounters either end of the list.\n * @param {?} delta\n * @param {?} items\n * @return {?}\n */\nprivate _setActiveInWrapMode(delta: number, items: T[]): void {\n    // when active item would leave menu, wrap to beginning or end\n    this._activeItemIndex =\n      (this._activeItemIndex + delta + items.length) % items.length;\n\n    // skip all disabled menu items recursively until an enabled one is reached\n    if (items[this._activeItemIndex].disabled) {\n      this._setActiveInWrapMode(delta, items);\n    } else {\n      this.setActiveItem(this._activeItemIndex);\n    }\n  }\n/**\n * Sets the active item properly given the default mode. In other words, it will\n * continue to move down the list until it finds an item that is not disabled. If\n * it encounters either end of the list, it will stop and not wrap.\n * @param {?} delta\n * @param {?} items\n * @return {?}\n */\nprivate _setActiveInDefaultMode(delta: number, items: T[]): void {\n    this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n  }\n/**\n * Sets the active item to the first enabled item starting at the index specified. If the\n * item is disabled, it will move in the fallbackDelta direction until it either\n * finds an enabled item or encounters the end of the list.\n * @param {?} index\n * @param {?} fallbackDelta\n * @param {?=} items\n * @return {?}\n */\nprivate _setActiveItemByIndex(index: number, fallbackDelta: number,\n                                  items = this._items.toArray()): void {\n    if (!items[index]) { return; }\n    while (items[index].disabled) {\n      index += fallbackDelta;\n      if (!items[index]) { return; }\n    }\n    this.setActiveItem(index);\n  }\n\n}\n\nfunction ListKeyManager_tsickle_Closure_declarations() {\n/** @type {?} */\nListKeyManager.prototype._activeItemIndex;\n/** @type {?} */\nListKeyManager.prototype._activeItem;\n/** @type {?} */\nListKeyManager.prototype._tabOut;\n/** @type {?} */\nListKeyManager.prototype._wrap;\n/** @type {?} */\nListKeyManager.prototype._items;\n}\n\n"]}