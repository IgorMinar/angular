{"version":3,"sources":["../../../../src/lib/tabs/tab-header.ts"],"names":[],"mappings":"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","file":"tab-header.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {\n  ViewChild,\n  Component,\n  Input,\n  QueryList,\n  ElementRef,\n  ViewEncapsulation,\n  ContentChildren,\n  Output,\n  EventEmitter,\n  Optional,\n  AfterContentChecked,\n  AfterContentInit,\n  OnDestroy,\n  NgZone,\n  Renderer2,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n} from '@angular/core';\nimport {\n  RIGHT_ARROW,\n  LEFT_ARROW,\n  ENTER,\n  Directionality,\n  Direction,\n} from '../core';\nimport {MdTabLabelWrapper} from './tab-label-wrapper';\nimport {MdInkBar} from './ink-bar';\nimport {Subscription} from 'rxjs/Subscription';\nimport {auditTime, startWith} from '../core/rxjs/index';\nimport {of as observableOf} from 'rxjs/observable/of';\nimport {merge} from 'rxjs/observable/merge';\nimport {fromEvent} from 'rxjs/observable/fromEvent';\nimport {CanDisableRipple, mixinDisableRipple} from '../core/common-behaviors/disable-ripple';\n\n\n/**\n * The directions that scrolling can go in when the header's tabs exceed the header width. 'After'\n * will scroll the header towards the end of the tabs list and 'before' will scroll towards the\n * beginning of the list.\n */\nexport type ScrollDirection = 'after' | 'before';\n/**\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n * provide a small affordance to the label next to it.\n */\nconst EXAGGERATED_OVERSCROLL = 60;\n/**\n * \\@docs-private\n */\nexport class MdTabHeaderBase {}\nexport const /** @type {?} */ _MdTabHeaderMixinBase = mixinDisableRipple(MdTabHeaderBase);\n/**\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n * width of the header container, then arrows will be displayed to allow the user to scroll\n * left and right across the header.\n * \\@docs-private\n */\nexport class MdTabHeader extends _MdTabHeaderMixinBase\n    implements AfterContentChecked, AfterContentInit, OnDestroy, CanDisableRipple {\n\n   _labelWrappers: QueryList<MdTabLabelWrapper>;\n   _inkBar: MdInkBar;\n   _tabListContainer: ElementRef;\n   _tabList: ElementRef;\n/**\n * The tab index that is focused.\n */\nprivate _focusIndex: number = 0;\n/**\n * The distance in pixels that the tab labels should be translated to the left.\n */\nprivate _scrollDistance = 0;\n/**\n * Whether the header should scroll to the selected index after the view has been checked.\n */\nprivate _selectedIndexChanged = false;\n/**\n * Combines listeners that will re-align the ink bar whenever they're invoked.\n */\nprivate _realignInkBar: Subscription | null = null;\n/**\n * Whether the controls for pagination should be displayed\n */\n_showPaginationControls = false;\n/**\n * Whether the tab list can be scrolled more towards the end of the tab label list.\n */\n_disableScrollAfter = true;\n/**\n * Whether the tab list can be scrolled more towards the beginning of the tab label list.\n */\n_disableScrollBefore = true;\n/**\n * The number of tab labels that are displayed on the header. When this changes, the header\n * should re-evaluate the scroll position.\n */\nprivate _tabLabelCount: number;\n/**\n * Whether the scroll distance has changed and should be applied after the view is checked.\n */\nprivate _scrollDistanceChanged: boolean;\nprivate _selectedIndex: number = 0;\n/**\n * The index of the active tab.\n * @return {?}\n */\nget selectedIndex(): number { return this._selectedIndex; }\n/**\n * @param {?} value\n * @return {?}\n */\nset selectedIndex(value: number) {\n    this._selectedIndexChanged = this._selectedIndex != value;\n\n    this._selectedIndex = value;\n    this._focusIndex = value;\n  }\n/**\n * Event emitted when the option is selected.\n */\nselectFocusedIndex = new EventEmitter();\n/**\n * Event emitted when a label is focused.\n */\nindexFocused = new EventEmitter();\n/**\n * @param {?} _elementRef\n * @param {?} _ngZone\n * @param {?} _renderer\n * @param {?} _changeDetectorRef\n * @param {?} _dir\n */\nconstructor(private _elementRef: ElementRef,\nprivate _ngZone: NgZone,\nprivate _renderer: Renderer2,\nprivate _changeDetectorRef: ChangeDetectorRef,\nprivate _dir: Directionality) {\n    super();\n  }\n/**\n * @return {?}\n */\nngAfterContentChecked(): void {\n    // If the number of tab labels have changed, check if scrolling should be enabled\n    if (this._tabLabelCount != this._labelWrappers.length) {\n      this._updatePagination();\n      this._tabLabelCount = this._labelWrappers.length;\n      this._changeDetectorRef.markForCheck();\n    }\n\n    // If the selected index has changed, scroll to the label and check if the scrolling controls\n    // should be disabled.\n    if (this._selectedIndexChanged) {\n      this._scrollToLabel(this._selectedIndex);\n      this._checkScrollingControls();\n      this._alignInkBarToSelectedTab();\n      this._selectedIndexChanged = false;\n      this._changeDetectorRef.markForCheck();\n    }\n\n    // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n    // then translate the header to reflect this.\n    if (this._scrollDistanceChanged) {\n      this._updateTabScrollPosition();\n      this._scrollDistanceChanged = false;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n/**\n * @param {?} event\n * @return {?}\n */\n_handleKeydown(event: KeyboardEvent) {\n    switch (event.keyCode) {\n      case RIGHT_ARROW:\n        this._focusNextTab();\n        break;\n      case LEFT_ARROW:\n        this._focusPreviousTab();\n        break;\n      case ENTER:\n        this.selectFocusedIndex.emit(this.focusIndex);\n        break;\n    }\n  }\n/**\n * Aligns the ink bar to the selected tab on load.\n * @return {?}\n */\nngAfterContentInit() {\n    this._realignInkBar = this._ngZone.runOutsideAngular(() => {\n      let /** @type {?} */ dirChange = this._dir ? this._dir.change : observableOf(null);\n      let /** @type {?} */ resize = typeof window !== 'undefined' ?\n          auditTime.call(fromEvent(window, 'resize'), 10) :\n          observableOf(null);\n\n      return startWith.call(merge(dirChange, resize), null).subscribe(() => {\n        this._updatePagination();\n        this._alignInkBarToSelectedTab();\n      });\n    });\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    if (this._realignInkBar) {\n      this._realignInkBar.unsubscribe();\n      this._realignInkBar = null;\n    }\n  }\n/**\n * Callback for when the MutationObserver detects that the content has changed.\n * @return {?}\n */\n_onContentChanges() {\n    this._updatePagination();\n    this._alignInkBarToSelectedTab();\n    this._changeDetectorRef.markForCheck();\n  }\n/**\n * Updating the view whether pagination should be enabled or not\n * @return {?}\n */\n_updatePagination() {\n    this._checkPaginationEnabled();\n    this._checkScrollingControls();\n    this._updateTabScrollPosition();\n  }\n/**\n * When the focus index is set, we must manually send focus to the correct label\n * @param {?} value\n * @return {?}\n */\nset focusIndex(value: number) {\n    if (!this._isValidIndex(value) || this._focusIndex == value) { return; }\n\n    this._focusIndex = value;\n    this.indexFocused.emit(value);\n    this._setTabFocus(value);\n  }\n/**\n * Tracks which element has focus; used for keyboard navigation\n * @return {?}\n */\nget focusIndex(): number { return this._focusIndex; }\n/**\n * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n * providing a valid index and return true.\n * @param {?} index\n * @return {?}\n */\n_isValidIndex(index: number): boolean {\n    if (!this._labelWrappers) { return true; }\n\n    const /** @type {?} */ tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;\n    return !!tab && !tab.disabled;\n  }\n/**\n * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n * scrolling is enabled.\n * @param {?} tabIndex\n * @return {?}\n */\n_setTabFocus(tabIndex: number) {\n    if (this._showPaginationControls) {\n      this._scrollToLabel(tabIndex);\n    }\n\n    if (this._labelWrappers && this._labelWrappers.length) {\n      this._labelWrappers.toArray()[tabIndex].focus();\n\n      // Do not let the browser manage scrolling to focus the element, this will be handled\n      // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\n      // should be the full width minus the offset width.\n      const /** @type {?} */ containerEl = this._tabListContainer.nativeElement;\n      const /** @type {?} */ dir = this._getLayoutDirection();\n\n      if (dir == 'ltr') {\n        containerEl.scrollLeft = 0;\n      } else {\n        containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n      }\n    }\n  }\n/**\n * Moves the focus towards the beginning or the end of the list depending on the offset provided.\n * Valid offsets are 1 and -1.\n * @param {?} offset\n * @return {?}\n */\n_moveFocus(offset: number) {\n    if (this._labelWrappers) {\n      const /** @type {?} */ tabs: MdTabLabelWrapper[] = this._labelWrappers.toArray();\n\n      for (let /** @type {?} */ i = this.focusIndex + offset; i < tabs.length && i >= 0; i += offset) {\n        if (this._isValidIndex(i)) {\n          this.focusIndex = i;\n          return;\n        }\n      }\n    }\n  }\n/**\n * Increment the focus index by 1 until a valid tab is found.\n * @return {?}\n */\n_focusNextTab(): void {\n    this._moveFocus(this._getLayoutDirection() == 'ltr' ? 1 : -1);\n  }\n/**\n * Decrement the focus index by 1 until a valid tab is found.\n * @return {?}\n */\n_focusPreviousTab(): void {\n    this._moveFocus(this._getLayoutDirection() == 'ltr' ? -1 : 1);\n  }\n/**\n * The layout direction of the containing app.\n * @return {?}\n */\n_getLayoutDirection(): Direction {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n/**\n * Performs the CSS transformation on the tab list that will cause the list to scroll.\n * @return {?}\n */\n_updateTabScrollPosition() {\n    const /** @type {?} */ scrollDistance = this.scrollDistance;\n    const /** @type {?} */ translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;\n\n    this._renderer.setStyle(this._tabList.nativeElement, 'transform',\n        `translate3d(${translateX}px, 0, 0)`);\n  }\n/**\n * Sets the distance in pixels that the tab header should be transformed in the X-axis.\n * @param {?} v\n * @return {?}\n */\nset scrollDistance(v: number) {\n    this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), v));\n\n    // Mark that the scroll distance has changed so that after the view is checked, the CSS\n    // transformation can move the header.\n    this._scrollDistanceChanged = true;\n    this._checkScrollingControls();\n  }\n/**\n * @return {?}\n */\nget scrollDistance(): number { return this._scrollDistance; }\n/**\n * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n * the end of the list, respectively). The distance to scroll is computed to be a third of the\n * length of the tab list view window.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @param {?} scrollDir\n * @return {?}\n */\n_scrollHeader(scrollDir: ScrollDirection) {\n    const /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\n\n    // Move the scroll distance one-third the length of the tab list's viewport.\n    this.scrollDistance += (scrollDir == 'before' ? -1 : 1) * viewLength / 3;\n  }\n/**\n * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @param {?} labelIndex\n * @return {?}\n */\n_scrollToLabel(labelIndex: number) {\n    const /** @type {?} */ selectedLabel = this._labelWrappers ? this._labelWrappers.toArray()[labelIndex] : null;\n\n    if (!selectedLabel) { return; }\n\n    // The view length is the visible width of the tab labels.\n    const /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\n\n    let /** @type {?} */ labelBeforePos: number, /** @type {?} */ labelAfterPos: number;\n    if (this._getLayoutDirection() == 'ltr') {\n      labelBeforePos = selectedLabel.getOffsetLeft();\n      labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();\n    } else {\n      labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();\n      labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();\n    }\n\n    const /** @type {?} */ beforeVisiblePos = this.scrollDistance;\n    const /** @type {?} */ afterVisiblePos = this.scrollDistance + viewLength;\n\n    if (labelBeforePos < beforeVisiblePos) {\n      // Scroll header to move label to the before direction\n      this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n    } else if (labelAfterPos > afterVisiblePos) {\n      // Scroll header to move label to the after direction\n      this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n    }\n  }\n/**\n * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n * tab list is wider than the size of the header container, then the pagination controls should\n * be shown.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @return {?}\n */\n_checkPaginationEnabled() {\n    this._showPaginationControls =\n        this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n\n    if (!this._showPaginationControls) {\n      this.scrollDistance = 0;\n    }\n\n    this._changeDetectorRef.markForCheck();\n  }\n/**\n * Evaluate whether the before and after controls should be enabled or disabled.\n * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n * before button. If the header is at the end of the list (scroll distance is equal to the\n * maximum distance we can scroll), then disable the after button.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @return {?}\n */\n_checkScrollingControls() {\n    // Check if the pagination arrows should be activated.\n    this._disableScrollBefore = this.scrollDistance == 0;\n    this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n    this._changeDetectorRef.markForCheck();\n  }\n/**\n * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n * is equal to the difference in width between the tab list container and tab header container.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @return {?}\n */\n_getMaxScrollDistance(): number {\n    const /** @type {?} */ lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n    const /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\n    return (lengthOfTabList - viewLength) || 0;\n  }\n/**\n * Tells the ink-bar to align itself to the current label wrapper\n * @return {?}\n */\nprivate _alignInkBarToSelectedTab(): void {\n    const /** @type {?} */ selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length\n        ? this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement\n        : null;\n\n    this._inkBar.alignToElement(selectedLabelWrapper);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  moduleId: module.id,\n  selector: 'md-tab-header, mat-tab-header',\n  templateUrl: 'tab-header.html',\n  styleUrls: ['tab-header.css'],\n  inputs: ['disableRipple'],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    'class': 'mat-tab-header',\n    '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',\n    '[class.mat-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\",\n  }\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: NgZone, },\n{type: Renderer2, },\n{type: ChangeDetectorRef, },\n{type: Directionality, decorators: [{ type: Optional }, ]},\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'_labelWrappers': [{ type: ContentChildren, args: [MdTabLabelWrapper, ] },],\n'_inkBar': [{ type: ViewChild, args: [MdInkBar, ] },],\n'_tabListContainer': [{ type: ViewChild, args: ['tabListContainer', ] },],\n'_tabList': [{ type: ViewChild, args: ['tabList', ] },],\n'selectedIndex': [{ type: Input },],\n'selectFocusedIndex': [{ type: Output },],\n'indexFocused': [{ type: Output },],\n};\n}\n\nfunction MdTabHeader_tsickle_Closure_declarations() {\n/** @type {?} */\nMdTabHeader.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMdTabHeader.ctorParameters;\n/** @type {?} */\nMdTabHeader.propDecorators;\n/** @type {?} */\nMdTabHeader.prototype._labelWrappers;\n/** @type {?} */\nMdTabHeader.prototype._inkBar;\n/** @type {?} */\nMdTabHeader.prototype._tabListContainer;\n/** @type {?} */\nMdTabHeader.prototype._tabList;\n/**\n * The tab index that is focused.\n * @type {?}\n */\nMdTabHeader.prototype._focusIndex;\n/**\n * The distance in pixels that the tab labels should be translated to the left.\n * @type {?}\n */\nMdTabHeader.prototype._scrollDistance;\n/**\n * Whether the header should scroll to the selected index after the view has been checked.\n * @type {?}\n */\nMdTabHeader.prototype._selectedIndexChanged;\n/**\n * Combines listeners that will re-align the ink bar whenever they're invoked.\n * @type {?}\n */\nMdTabHeader.prototype._realignInkBar;\n/**\n * Whether the controls for pagination should be displayed\n * @type {?}\n */\nMdTabHeader.prototype._showPaginationControls;\n/**\n * Whether the tab list can be scrolled more towards the end of the tab label list.\n * @type {?}\n */\nMdTabHeader.prototype._disableScrollAfter;\n/**\n * Whether the tab list can be scrolled more towards the beginning of the tab label list.\n * @type {?}\n */\nMdTabHeader.prototype._disableScrollBefore;\n/**\n * The number of tab labels that are displayed on the header. When this changes, the header\n * should re-evaluate the scroll position.\n * @type {?}\n */\nMdTabHeader.prototype._tabLabelCount;\n/**\n * Whether the scroll distance has changed and should be applied after the view is checked.\n * @type {?}\n */\nMdTabHeader.prototype._scrollDistanceChanged;\n/** @type {?} */\nMdTabHeader.prototype._selectedIndex;\n/**\n * Event emitted when the option is selected.\n * @type {?}\n */\nMdTabHeader.prototype.selectFocusedIndex;\n/**\n * Event emitted when a label is focused.\n * @type {?}\n */\nMdTabHeader.prototype.indexFocused;\n/** @type {?} */\nMdTabHeader.prototype._elementRef;\n/** @type {?} */\nMdTabHeader.prototype._ngZone;\n/** @type {?} */\nMdTabHeader.prototype._renderer;\n/** @type {?} */\nMdTabHeader.prototype._changeDetectorRef;\n/** @type {?} */\nMdTabHeader.prototype._dir;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}