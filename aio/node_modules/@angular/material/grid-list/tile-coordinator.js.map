{"version":3,"sources":["../../../../src/lib/grid-list/tile-coordinator.ts"],"names":[],"mappings":"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","file":"tile-coordinator.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {QueryList} from '@angular/core';\nimport {MdGridTile} from './grid-tile';\n/**\n * Class for determining, from a list of tiles, the (row, col) position of each of those tiles\n * in the grid. This is necessary (rather than just rendering the tiles in normal document flow)\n * because the tiles can have a rowspan.\n * \n * The positioning algorithm greedily places each tile as soon as it encounters a gap in the grid\n * large enough to accommodate it so that the tiles still render in the same order in which they\n * are given.\n * \n * The basis of the algorithm is the use of an array to track the already placed tiles. Each\n * element of the array corresponds to a column, and the value indicates how many cells in that\n * column are already occupied; zero indicates an empty cell. Moving \"down\" to the next row\n * decrements each value in the tracking array (indicating that the column is one cell closer to\n * being free).\n * \n * \\@docs-private\n */\nexport class TileCoordinator {\n/**\n * Tracking array (see class description).\n */\ntracker: number[];\n/**\n * Index at which the search for the next gap will start.\n */\ncolumnIndex: number = 0;\n/**\n * The current row index.\n */\nrowIndex: number = 0;\n/**\n * Gets the total number of rows occupied by tiles\n * @return {?}\n */\nget rowCount(): number { return this.rowIndex + 1; }\n/**\n * Gets the total span of rows occupied by tiles.\n * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2.\n * @return {?}\n */\nget rowspan() {\n    let /** @type {?} */ lastRowMax = Math.max(...this.tracker);\n    // if any of the tiles has a rowspan that pushes it beyond the total row count,\n    // add the difference to the rowcount\n    return lastRowMax > 1 ? this.rowCount + lastRowMax - 1 : this.rowCount;\n  }\n/**\n * The computed (row, col) position of each tile (the output).\n */\npositions: TilePosition[];\n/**\n * @param {?} numColumns\n * @param {?} tiles\n */\nconstructor(numColumns: number, tiles: QueryList<MdGridTile>) {\n    this.tracker = new Array(numColumns);\n    this.tracker.fill(0, 0, this.tracker.length);\n\n    this.positions = tiles.map(tile => this._trackTile(tile));\n  }\n/**\n * Calculates the row and col position of a tile.\n * @param {?} tile\n * @return {?}\n */\nprivate _trackTile(tile: MdGridTile): TilePosition {\n    // Find a gap large enough for this tile.\n    let /** @type {?} */ gapStartIndex = this._findMatchingGap(tile.colspan);\n\n    // Place tile in the resulting gap.\n    this._markTilePosition(gapStartIndex, tile);\n\n    // The next time we look for a gap, the search will start at columnIndex, which should be\n    // immediately after the tile that has just been placed.\n    this.columnIndex = gapStartIndex + tile.colspan;\n\n    return new TilePosition(this.rowIndex, gapStartIndex);\n  }\n/**\n * Finds the next available space large enough to fit the tile.\n * @param {?} tileCols\n * @return {?}\n */\nprivate _findMatchingGap(tileCols: number): number {\n    if (tileCols > this.tracker.length) {\n      throw Error(`md-grid-list: tile with colspan ${tileCols} is wider than ` +\n                      `grid with cols=\"${this.tracker.length}\".`);\n    }\n\n    // Start index is inclusive, end index is exclusive.\n    let /** @type {?} */ gapStartIndex = -1;\n    let /** @type {?} */ gapEndIndex = -1;\n\n    // Look for a gap large enough to fit the given tile. Empty spaces are marked with a zero.\n    do {\n      // If we've reached the end of the row, go to the next row.\n      if (this.columnIndex + tileCols > this.tracker.length) {\n        this._nextRow();\n        continue;\n      }\n\n      gapStartIndex = this.tracker.indexOf(0, this.columnIndex);\n\n      // If there are no more empty spaces in this row at all, move on to the next row.\n      if (gapStartIndex == -1) {\n        this._nextRow();\n        continue;\n      }\n\n      gapEndIndex = this._findGapEndIndex(gapStartIndex);\n\n      // If a gap large enough isn't found, we want to start looking immediately after the current\n      // gap on the next iteration.\n      this.columnIndex = gapStartIndex + 1;\n\n      // Continue iterating until we find a gap wide enough for this tile.\n    } while (gapEndIndex - gapStartIndex < tileCols);\n    return gapStartIndex;\n  }\n/**\n * Move \"down\" to the next row.\n * @return {?}\n */\nprivate _nextRow(): void {\n    this.columnIndex = 0;\n    this.rowIndex++;\n\n    // Decrement all spaces by one to reflect moving down one row.\n    for (let /** @type {?} */ i = 0; i < this.tracker.length; i++) {\n      this.tracker[i] = Math.max(0, this.tracker[i] - 1);\n    }\n  }\n/**\n * Finds the end index (exclusive) of a gap given the index from which to start looking.\n * The gap ends when a non-zero value is found.\n * @param {?} gapStartIndex\n * @return {?}\n */\nprivate _findGapEndIndex(gapStartIndex: number): number {\n    for (let /** @type {?} */ i = gapStartIndex + 1; i < this.tracker.length; i++) {\n      if (this.tracker[i] != 0) {\n        return i;\n      }\n    }\n\n    // The gap ends with the end of the row.\n    return this.tracker.length;\n  }\n/**\n * Update the tile tracker to account for the given tile in the given space.\n * @param {?} start\n * @param {?} tile\n * @return {?}\n */\nprivate _markTilePosition(start: number, tile: MdGridTile): void {\n    for (let /** @type {?} */ i = 0; i < tile.colspan; i++) {\n      this.tracker[start + i] = tile.rowspan;\n    }\n  }\n}\n\nfunction TileCoordinator_tsickle_Closure_declarations() {\n/**\n * Tracking array (see class description).\n * @type {?}\n */\nTileCoordinator.prototype.tracker;\n/**\n * Index at which the search for the next gap will start.\n * @type {?}\n */\nTileCoordinator.prototype.columnIndex;\n/**\n * The current row index.\n * @type {?}\n */\nTileCoordinator.prototype.rowIndex;\n/**\n * The computed (row, col) position of each tile (the output).\n * @type {?}\n */\nTileCoordinator.prototype.positions;\n}\n\n/**\n * Simple data structure for tile position (row, col).\n * \\@docs-private\n */\nexport class TilePosition {\n/**\n * @param {?} row\n * @param {?} col\n */\nconstructor(public row: number,\npublic col: number) {}\n}\n\nfunction TilePosition_tsickle_Closure_declarations() {\n/** @type {?} */\nTilePosition.prototype.row;\n/** @type {?} */\nTilePosition.prototype.col;\n}\n\n"]}