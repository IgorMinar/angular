/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Component, ContentChildren, ElementRef, Input, Optional, Output, ChangeDetectionStrategy, EventEmitter, Renderer2, ViewEncapsulation, NgZone, Inject, ChangeDetectorRef, } from '@angular/core';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { Directionality, coerceBooleanProperty } from '../core';
import { FocusTrapFactory } from '../core/a11y/focus-trap';
import { ESCAPE } from '../core/keyboard/keycodes';
import { first, takeUntil, startWith } from '../core/rxjs/index';
import { DOCUMENT } from '@angular/platform-browser';
import { merge } from 'rxjs/observable/merge';
/**
 * Throws an exception when two MdSidenav are matching the same side.
 * @param {?} align
 * @return {?}
 */
export function throwMdDuplicatedSidenavError(align) {
    throw Error("A sidenav was already declared for 'align=\"" + align + "\"'");
}
/**
 * Sidenav toggle promise result.
 * @deprecated
 */
var MdSidenavToggleResult = (function () {
    /**
     * @param {?} type
     * @param {?} animationFinished
     */
    function MdSidenavToggleResult(type, animationFinished) {
        this.type = type;
        this.animationFinished = animationFinished;
    }
    return MdSidenavToggleResult;
}());
export { MdSidenavToggleResult };
function MdSidenavToggleResult_tsickle_Closure_declarations() {
    /** @type {?} */
    MdSidenavToggleResult.prototype.type;
    /** @type {?} */
    MdSidenavToggleResult.prototype.animationFinished;
}
/**
 * <md-sidenav> component.
 *
 * This component corresponds to the drawer of the sidenav.
 *
 * Please refer to README.md for examples on how to use it.
 */
var MdSidenav = (function () {
    /**
     * @param {?} _elementRef
     * @param {?} _focusTrapFactory
     * @param {?} _doc
     */
    function MdSidenav(_elementRef, _focusTrapFactory, _doc) {
        var _this = this;
        this._elementRef = _elementRef;
        this._focusTrapFactory = _focusTrapFactory;
        this._doc = _doc;
        this._elementFocusedBeforeSidenavWasOpened = null;
        /**
         * Whether the sidenav is initialized. Used for disabling the initial animation.
         */
        this._enableAnimations = false;
        /**
         * Alignment of the sidenav (direction neutral); whether 'start' or 'end'.
         */
        this._align = 'start';
        /**
         * Mode of the sidenav; one of 'over', 'push' or 'side'.
         */
        this.mode = 'over';
        this._disableClose = false;
        /**
         * Whether the sidenav is opened.
         */
        this._opened = false;
        /**
         * Emits whenever the sidenav has started animating.
         */
        this._animationStarted = new EventEmitter();
        /**
         * Whether the sidenav is animating. Used to prevent overlapping animations.
         */
        this._isAnimating = false;
        /**
         * Event emitted when the sidenav is fully opened.
         */
        this.onOpen = new EventEmitter();
        /**
         * Event emitted when the sidenav is fully closed.
         */
        this.onClose = new EventEmitter();
        /**
         * Event emitted when the sidenav alignment changes.
         */
        this.onAlignChanged = new EventEmitter();
        this.onOpen.subscribe(function () {
            if (_this._doc) {
                _this._elementFocusedBeforeSidenavWasOpened = _this._doc.activeElement;
            }
            if (_this.isFocusTrapEnabled && _this._focusTrap) {
                _this._focusTrap.focusInitialElementWhenReady();
            }
        });
        this.onClose.subscribe(function () { return _this._restoreFocus(); });
    }
    Object.defineProperty(MdSidenav.prototype, "align", {
        /**
         * Direction which the sidenav is aligned in.
         * @return {?}
         */
        get: function () { return this._align; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            // Make sure we have a valid value.
            value = value === 'end' ? 'end' : 'start';
            if (value != this._align) {
                this._align = value;
                this.onAlignChanged.emit();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSidenav.prototype, "disableClose", {
        /**
         * Whether the sidenav can be closed with the escape key or not.
         * @return {?}
         */
        get: function () { return this._disableClose; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) { this._disableClose = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSidenav.prototype, "isFocusTrapEnabled", {
        /**
         * @return {?}
         */
        get: function () {
            // The focus trap is only enabled when the sidenav is open in any mode other than side.
            return this.opened && this.mode !== 'side';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * If focus is currently inside the sidenav, restores it to where it was before the sidenav
     * opened.
     * @return {?}
     */
    MdSidenav.prototype._restoreFocus = function () {
        var /** @type {?} */ activeEl = this._doc && this._doc.activeElement;
        if (activeEl && this._elementRef.nativeElement.contains(activeEl)) {
            if (this._elementFocusedBeforeSidenavWasOpened instanceof HTMLElement) {
                this._elementFocusedBeforeSidenavWasOpened.focus();
            }
            else {
                this._elementRef.nativeElement.blur();
            }
        }
        this._elementFocusedBeforeSidenavWasOpened = null;
    };
    /**
     * @return {?}
     */
    MdSidenav.prototype.ngAfterContentInit = function () {
        var _this = this;
        this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);
        this._focusTrap.enabled = this.isFocusTrapEnabled;
        Promise.resolve().then(function () { return _this._enableAnimations = true; });
    };
    /**
     * @return {?}
     */
    MdSidenav.prototype.ngOnDestroy = function () {
        if (this._focusTrap) {
            this._focusTrap.destroy();
        }
    };
    Object.defineProperty(MdSidenav.prototype, "opened", {
        /**
         * Whether the sidenav is opened. We overload this because we trigger an event when it
         * starts or end.
         * @return {?}
         */
        get: function () { return this._opened; },
        /**
         * @param {?} v
         * @return {?}
         */
        set: function (v) {
            this.toggle(coerceBooleanProperty(v));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Open the sidenav.
     * @return {?}
     */
    MdSidenav.prototype.open = function () {
        return this.toggle(true);
    };
    /**
     * Close the sidenav.
     * @return {?}
     */
    MdSidenav.prototype.close = function () {
        return this.toggle(false);
    };
    /**
     * Toggle this sidenav.
     * @param {?=} isOpen Whether the sidenav should be open.
     * @return {?}
     */
    MdSidenav.prototype.toggle = function (isOpen) {
        var _this = this;
        if (isOpen === void 0) { isOpen = !this.opened; }
        if (!this._isAnimating) {
            this._opened = isOpen;
            this._currentTogglePromise = new Promise(function (resolve) {
                first.call(isOpen ? _this.onOpen : _this.onClose).subscribe(resolve);
            });
            if (this._focusTrap) {
                this._focusTrap.enabled = this.isFocusTrapEnabled;
            }
        }
        // TODO(crisbeto): This promise is here backwards-compatibility.
        // It should be removed next time we do breaking changes in the sidenav.
        return ((this._currentTogglePromise));
    };
    /**
     * Handles the keyboard events.
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    MdSidenav.prototype.handleKeydown = function (event) {
        if (event.keyCode === ESCAPE && !this.disableClose) {
            this.close();
            event.stopPropagation();
        }
    };
    /**
     * Figures out the state of the sidenav animation.
     * @return {?}
     */
    MdSidenav.prototype._getAnimationState = function () {
        if (this.opened) {
            return this._enableAnimations ? 'open' : 'open-instant';
        }
        return 'void';
    };
    /**
     * @return {?}
     */
    MdSidenav.prototype._onAnimationStart = function () {
        this._isAnimating = true;
        this._animationStarted.emit();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MdSidenav.prototype._onAnimationEnd = function (event) {
        var fromState = event.fromState, toState = event.toState;
        if (toState === 'open' && fromState === 'void') {
            this.onOpen.emit(new MdSidenavToggleResult('open', true));
        }
        else if (toState === 'void' && fromState === 'open') {
            this.onClose.emit(new MdSidenavToggleResult('close', true));
        }
        this._isAnimating = false;
        this._currentTogglePromise = null;
    };
    Object.defineProperty(MdSidenav.prototype, "_width", {
        /**
         * @return {?}
         */
        get: function () {
            return this._elementRef.nativeElement ? (this._elementRef.nativeElement.offsetWidth || 0) : 0;
        },
        enumerable: true,
        configurable: true
    });
    return MdSidenav;
}());
export { MdSidenav };
MdSidenav.decorators = [
    { type: Component, args: [{selector: 'md-sidenav, mat-sidenav',
                template: "<ng-content></ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('transform', [
                        state('open, open-instant', style({
                            transform: 'translate3d(0, 0, 0)',
                            visibility: 'visible',
                        })),
                        state('void', style({
                            visibility: 'hidden',
                        })),
                        transition('void => open-instant', animate('0ms')),
                        transition('void <=> open', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))
                    ])
                ],
                host: {
                    'class': 'mat-sidenav',
                    '[@transform]': '_getAnimationState()',
                    '(@transform.start)': '_onAnimationStart()',
                    '(@transform.done)': '_onAnimationEnd($event)',
                    '(keydown)': 'handleKeydown($event)',
                    // must prevent the browser from aligning text based on value
                    '[attr.align]': 'null',
                    '[class.mat-sidenav-end]': 'align === "end"',
                    '[class.mat-sidenav-over]': 'mode === "over"',
                    '[class.mat-sidenav-push]': 'mode === "push"',
                    '[class.mat-sidenav-side]': 'mode === "side"',
                    'tabIndex': '-1'
                },
            },] },
];
/**
 * @nocollapse
 */
MdSidenav.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: FocusTrapFactory, },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] },] },
]; };
MdSidenav.propDecorators = {
    'align': [{ type: Input },],
    'mode': [{ type: Input },],
    'disableClose': [{ type: Input },],
    'onOpen': [{ type: Output, args: ['open',] },],
    'onClose': [{ type: Output, args: ['close',] },],
    'onAlignChanged': [{ type: Output, args: ['align-changed',] },],
    'opened': [{ type: Input },],
};
function MdSidenav_tsickle_Closure_declarations() {
    /** @type {?} */
    MdSidenav.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    MdSidenav.ctorParameters;
    /** @type {?} */
    MdSidenav.propDecorators;
    /** @type {?} */
    MdSidenav.prototype._focusTrap;
    /** @type {?} */
    MdSidenav.prototype._elementFocusedBeforeSidenavWasOpened;
    /**
     * Whether the sidenav is initialized. Used for disabling the initial animation.
     * @type {?}
     */
    MdSidenav.prototype._enableAnimations;
    /**
     * Alignment of the sidenav (direction neutral); whether 'start' or 'end'.
     * @type {?}
     */
    MdSidenav.prototype._align;
    /**
     * Mode of the sidenav; one of 'over', 'push' or 'side'.
     * @type {?}
     */
    MdSidenav.prototype.mode;
    /** @type {?} */
    MdSidenav.prototype._disableClose;
    /**
     * Whether the sidenav is opened.
     * @type {?}
     */
    MdSidenav.prototype._opened;
    /**
     * Emits whenever the sidenav has started animating.
     * @type {?}
     */
    MdSidenav.prototype._animationStarted;
    /**
     * Whether the sidenav is animating. Used to prevent overlapping animations.
     * @type {?}
     */
    MdSidenav.prototype._isAnimating;
    /**
     * Promise that resolves when the open/close animation completes. It is here for backwards
     * compatibility and should be removed next time we do sidenav breaking changes.
     * @deprecated
     * @type {?}
     */
    MdSidenav.prototype._currentTogglePromise;
    /**
     * Event emitted when the sidenav is fully opened.
     * @type {?}
     */
    MdSidenav.prototype.onOpen;
    /**
     * Event emitted when the sidenav is fully closed.
     * @type {?}
     */
    MdSidenav.prototype.onClose;
    /**
     * Event emitted when the sidenav alignment changes.
     * @type {?}
     */
    MdSidenav.prototype.onAlignChanged;
    /** @type {?} */
    MdSidenav.prototype._elementRef;
    /** @type {?} */
    MdSidenav.prototype._focusTrapFactory;
    /** @type {?} */
    MdSidenav.prototype._doc;
}
/**
 * <md-sidenav-container> component.
 *
 * This is the parent component to one or two <md-sidenav>s that validates the state internally
 * and coordinates the backdrop and content styling.
 */
var MdSidenavContainer = (function () {
    /**
     * @param {?} _dir
     * @param {?} _element
     * @param {?} _renderer
     * @param {?} _ngZone
     * @param {?} _changeDetectorRef
     */
    function MdSidenavContainer(_dir, _element, _renderer, _ngZone, _changeDetectorRef) {
        var _this = this;
        this._dir = _dir;
        this._element = _element;
        this._renderer = _renderer;
        this._ngZone = _ngZone;
        this._changeDetectorRef = _changeDetectorRef;
        /**
         * Event emitted when the sidenav backdrop is clicked.
         */
        this.backdropClick = new EventEmitter();
        // If a `Dir` directive exists up the tree, listen direction changes and update the left/right
        // properties to point to the proper start/end.
        if (_dir != null) {
            _dir.change.subscribe(function () { return _this._validateDrawers(); });
        }
    }
    Object.defineProperty(MdSidenavContainer.prototype, "start", {
        /**
         * The sidenav child with the `start` alignment.
         * @return {?}
         */
        get: function () { return this._start; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSidenavContainer.prototype, "end", {
        /**
         * The sidenav child with the `end` alignment.
         * @return {?}
         */
        get: function () { return this._end; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MdSidenavContainer.prototype.ngAfterContentInit = function () {
        var _this = this;
        startWith.call(this._sidenavs.changes, null).subscribe(function () {
            _this._validateDrawers();
            _this._sidenavs.forEach(function (sidenav) {
                _this._watchSidenavToggle(sidenav);
                _this._watchSidenavAlign(sidenav);
            });
        });
    };
    /**
     * Calls `open` of both start and end sidenavs
     * @return {?}
     */
    MdSidenavContainer.prototype.open = function () {
        this._sidenavs.forEach(function (sidenav) { return sidenav.open(); });
    };
    /**
     * Calls `close` of both start and end sidenavs
     * @return {?}
     */
    MdSidenavContainer.prototype.close = function () {
        this._sidenavs.forEach(function (sidenav) { return sidenav.close(); });
    };
    /**
     * Subscribes to sidenav events in order to set a class on the main container element when the
     * sidenav is open and the backdrop is visible. This ensures any overflow on the container element
     * is properly hidden.
     * @param {?} sidenav
     * @return {?}
     */
    MdSidenavContainer.prototype._watchSidenavToggle = function (sidenav) {
        var _this = this;
        takeUntil.call(sidenav._animationStarted, this._sidenavs.changes).subscribe(function () {
            // Set the transition class on the container so that the animations occur. This should not
            // be set initially because animations should only be triggered via a change in state.
            _this._renderer.addClass(_this._element.nativeElement, 'mat-sidenav-transition');
            _this._updateStyles();
            _this._changeDetectorRef.markForCheck();
        });
        if (sidenav.mode !== 'side') {
            takeUntil.call(merge(sidenav.onOpen, sidenav.onClose), this._sidenavs.changes).subscribe(function () {
                return _this._setContainerClass(sidenav.opened);
            });
        }
    };
    /**
     * Subscribes to sidenav onAlignChanged event in order to re-validate drawers when the align
     * changes.
     * @param {?} sidenav
     * @return {?}
     */
    MdSidenavContainer.prototype._watchSidenavAlign = function (sidenav) {
        var _this = this;
        if (!sidenav) {
            return;
        }
        // NOTE: We need to wait for the microtask queue to be empty before validating,
        // since both drawers may be swapping sides at the same time.
        takeUntil.call(sidenav.onAlignChanged, this._sidenavs.changes).subscribe(function () {
            return first.call(_this._ngZone.onMicrotaskEmpty).subscribe(function () { return _this._validateDrawers(); });
        });
    };
    /**
     * Toggles the 'mat-sidenav-opened' class on the main 'md-sidenav-container' element.
     * @param {?} isAdd
     * @return {?}
     */
    MdSidenavContainer.prototype._setContainerClass = function (isAdd) {
        if (isAdd) {
            this._renderer.addClass(this._element.nativeElement, 'mat-sidenav-opened');
        }
        else {
            this._renderer.removeClass(this._element.nativeElement, 'mat-sidenav-opened');
        }
    };
    /**
     * Validate the state of the sidenav children components.
     * @return {?}
     */
    MdSidenavContainer.prototype._validateDrawers = function () {
        var _this = this;
        this._start = this._end = null;
        // Ensure that we have at most one start and one end sidenav.
        this._sidenavs.forEach(function (sidenav) {
            if (sidenav.align == 'end') {
                if (_this._end != null) {
                    throwMdDuplicatedSidenavError('end');
                }
                _this._end = sidenav;
            }
            else {
                if (_this._start != null) {
                    throwMdDuplicatedSidenavError('start');
                }
                _this._start = sidenav;
            }
        });
        this._right = this._left = null;
        // Detect if we're LTR or RTL.
        if (this._dir == null || this._dir.value == 'ltr') {
            this._left = this._start;
            this._right = this._end;
        }
        else {
            this._left = this._end;
            this._right = this._start;
        }
    };
    /**
     * @return {?}
     */
    MdSidenavContainer.prototype._onBackdropClicked = function () {
        this.backdropClick.emit();
        this._closeModalSidenav();
    };
    /**
     * @return {?}
     */
    MdSidenavContainer.prototype._closeModalSidenav = function () {
        // Close all open sidenav's where closing is not disabled and the mode is not `side`.
        [this._start, this._end]
            .filter(function (sidenav) { return sidenav && !sidenav.disableClose && sidenav.mode !== 'side'; })
            .forEach(function (sidenav) { /** @type {?} */ return ((sidenav)).close(); });
    };
    /**
     * @return {?}
     */
    MdSidenavContainer.prototype._isShowingBackdrop = function () {
        return (this._isSidenavOpen(this._start) && ((this._start)).mode != 'side')
            || (this._isSidenavOpen(this._end) && ((this._end)).mode != 'side');
    };
    /**
     * @param {?} side
     * @return {?}
     */
    MdSidenavContainer.prototype._isSidenavOpen = function (side) {
        return side != null && side.opened;
    };
    /**
     * Return the width of the sidenav, if it's in the proper mode and opened.
     * This may relayout the view, so do not call this often.
     * @param {?} sidenav
     * @param {?} mode
     * @return {?}
     */
    MdSidenavContainer.prototype._getSidenavEffectiveWidth = function (sidenav, mode) {
        return (this._isSidenavOpen(sidenav) && sidenav.mode == mode) ? sidenav._width : 0;
    };
    /**
     * Recalculates and updates the inline styles. Note that this
     * should be used sparingly, because it causes a reflow.
     * @return {?}
     */
    MdSidenavContainer.prototype._updateStyles = function () {
        var /** @type {?} */ marginLeft = this._left ? this._getSidenavEffectiveWidth(this._left, 'side') : 0;
        var /** @type {?} */ marginRight = this._right ? this._getSidenavEffectiveWidth(this._right, 'side') : 0;
        var /** @type {?} */ leftWidth = this._left ? this._getSidenavEffectiveWidth(this._left, 'push') : 0;
        var /** @type {?} */ rightWidth = this._right ? this._getSidenavEffectiveWidth(this._right, 'push') : 0;
        this._styles = {
            marginLeft: marginLeft + "px",
            marginRight: marginRight + "px",
            transform: "translate3d(" + (leftWidth - rightWidth) + "px, 0, 0)"
        };
    };
    return MdSidenavContainer;
}());
export { MdSidenavContainer };
MdSidenavContainer.decorators = [
    { type: Component, args: [{selector: 'md-sidenav-container, mat-sidenav-container',
                template: "<div class=\"mat-sidenav-backdrop\" (click)=\"_onBackdropClicked()\" [class.mat-sidenav-shown]=\"_isShowingBackdrop()\"></div><ng-content select=\"md-sidenav, mat-sidenav\"></ng-content><div class=\"mat-sidenav-content\" [ngStyle]=\"_styles\" cdk-scrollable><ng-content></ng-content></div>",
                styles: [".mat-sidenav-container{position:relative;transform:translate3d(0,0,0);box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-sidenav-container[fullscreen]{position:absolute;top:0;left:0;right:0;bottom:0}.mat-sidenav-container[fullscreen].mat-sidenav-opened{overflow:hidden}.mat-sidenav-backdrop{position:absolute;top:0;left:0;right:0;bottom:0;display:block;z-index:2;visibility:hidden}.mat-sidenav-backdrop.mat-sidenav-shown{visibility:visible}@media screen and (-ms-high-contrast:active){.mat-sidenav-backdrop{opacity:.5}}.mat-sidenav-content{position:relative;transform:translate3d(0,0,0);display:block;height:100%;overflow:auto}.mat-sidenav{position:relative;transform:translate3d(0,0,0);display:block;position:absolute;top:0;bottom:0;z-index:3;min-width:5vw;outline:0;box-sizing:border-box;height:100%;overflow-y:auto;transform:translate3d(-100%,0,0)}.mat-sidenav.mat-sidenav-side{z-index:1}.mat-sidenav.mat-sidenav-end{right:0;transform:translate3d(100%,0,0)}[dir=rtl] .mat-sidenav{transform:translate3d(100%,0,0)}[dir=rtl] .mat-sidenav.mat-sidenav-end{left:0;right:auto;transform:translate3d(-100%,0,0)}.mat-sidenav.mat-sidenav-opened:not(.mat-sidenav-side),.mat-sidenav.mat-sidenav-opening:not(.mat-sidenav-side){box-shadow:0 8px 10px -5px rgba(0,0,0,.2),0 16px 24px 2px rgba(0,0,0,.14),0 6px 30px 5px rgba(0,0,0,.12)} .mat-sidenav-transition .mat-sidenav-content{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:transform,margin-left,margin-right}.mat-sidenav-transition .mat-sidenav-backdrop.mat-sidenav-shown{transition:background-color .4s cubic-bezier(.25,.8,.25,1)}"],
                host: {
                    'class': 'mat-sidenav-container',
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
            },] },
];
/**
 * @nocollapse
 */
MdSidenavContainer.ctorParameters = function () { return [
    { type: Directionality, decorators: [{ type: Optional },] },
    { type: ElementRef, },
    { type: Renderer2, },
    { type: NgZone, },
    { type: ChangeDetectorRef, },
]; };
MdSidenavContainer.propDecorators = {
    '_sidenavs': [{ type: ContentChildren, args: [MdSidenav,] },],
    'backdropClick': [{ type: Output },],
};
function MdSidenavContainer_tsickle_Closure_declarations() {
    /** @type {?} */
    MdSidenavContainer.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    MdSidenavContainer.ctorParameters;
    /** @type {?} */
    MdSidenavContainer.propDecorators;
    /** @type {?} */
    MdSidenavContainer.prototype._sidenavs;
    /**
     * Event emitted when the sidenav backdrop is clicked.
     * @type {?}
     */
    MdSidenavContainer.prototype.backdropClick;
    /**
     * The sidenav at the start/end alignment, independent of direction.
     * @type {?}
     */
    MdSidenavContainer.prototype._start;
    /** @type {?} */
    MdSidenavContainer.prototype._end;
    /**
     * The sidenav at the left/right. When direction changes, these will change as well.
     * They're used as aliases for the above to set the left/right style properly.
     * In LTR, _left == _start and _right == _end.
     * In RTL, _left == _end and _right == _start.
     * @type {?}
     */
    MdSidenavContainer.prototype._left;
    /** @type {?} */
    MdSidenavContainer.prototype._right;
    /**
     * Inline styles to be applied to the container.
     * @type {?}
     */
    MdSidenavContainer.prototype._styles;
    /** @type {?} */
    MdSidenavContainer.prototype._dir;
    /** @type {?} */
    MdSidenavContainer.prototype._element;
    /** @type {?} */
    MdSidenavContainer.prototype._renderer;
    /** @type {?} */
    MdSidenavContainer.prototype._ngZone;
    /** @type {?} */
    MdSidenavContainer.prototype._changeDetectorRef;
}
//# sourceMappingURL=sidenav.js.map