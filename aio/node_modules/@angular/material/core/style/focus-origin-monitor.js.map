{"version":3,"sources":["../../../../../src/lib/core/style/focus-origin-monitor.ts"],"names":[],"mappings":"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","file":"focus-origin-monitor.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Injectable,\n  NgZone,\n  OnDestroy,\n  Optional,\n  Output,\n  Renderer2,\n  SkipSelf,\n} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {Subject} from 'rxjs/Subject';\nimport {Subscription} from 'rxjs/Subscription';\nimport {Platform} from '../platform/platform';\nimport {of as observableOf} from 'rxjs/observable/of';\n\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nexport const /** @type {?} */ TOUCH_BUFFER_MS = 650;\n\n\nexport type FocusOrigin = 'touch' | 'mouse' | 'keyboard' | 'program' | null;\n\n\ntype MonitoredElementInfo = {\n  unlisten: Function,\n  checkChildren: boolean,\n  renderer: Renderer2,\n  subject: Subject<FocusOrigin>\n};\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nexport class FocusOriginMonitor {\n/**\n * The focus origin that the next focus event is a result of.\n */\nprivate _origin: FocusOrigin = null;\n/**\n * The FocusOrigin of the last focus event tracked by the FocusOriginMonitor.\n */\nprivate _lastFocusOrigin: FocusOrigin;\n/**\n * Whether the window has just been focused.\n */\nprivate _windowFocused = false;\n/**\n * The target of the last touch event.\n */\nprivate _lastTouchTarget: EventTarget | null;\n/**\n * The timeout id of the touch timeout, used to cancel timeout later.\n */\nprivate _touchTimeout: number;\n/**\n * Weak map of elements being monitored to their info.\n */\nprivate _elementInfo = new WeakMap<Element, MonitoredElementInfo>();\n/**\n * @param {?} _ngZone\n * @param {?} _platform\n */\nconstructor(private _ngZone: NgZone,\nprivate _platform: Platform) {\n    this._ngZone.runOutsideAngular(() => this._registerDocumentEvents());\n  }\n/**\n * Monitors focus on an element and applies appropriate CSS classes.\n * @param {?} element The element to monitor\n * @param {?} renderer The renderer to use to apply CSS classes to the element.\n * @param {?} checkChildren Whether to count the element as focused when its children are focused.\n * @return {?} An observable that emits when the focus state of the element changes.\n *     When the element is blurred, null will be emitted.\n */\nmonitor(\n      element: HTMLElement,\n      renderer: Renderer2,\n      checkChildren: boolean): Observable<FocusOrigin> {\n    // Do nothing if we're not on the browser platform.\n    if (!this._platform.isBrowser) {\n      return observableOf(null);\n    }\n    // Check if we're already monitoring this element.\n    if (this._elementInfo.has(element)) {\n      let /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */((\n      cachedInfo)).checkChildren = checkChildren;\n      return /** @type {?} */(( cachedInfo)).subject.asObservable();\n    }\n\n    // Create monitored element info.\n    let /** @type {?} */ info: MonitoredElementInfo = {\n      unlisten: () => {},\n      checkChildren: checkChildren,\n      renderer: renderer,\n      subject: new Subject<FocusOrigin>()\n    };\n    this._elementInfo.set(element, info);\n\n    // Start listening. We need to listen in capture phase since focus events don't bubble.\n    let /** @type {?} */ focusListener = (event: FocusEvent) => this._onFocus(event, element);\n    let /** @type {?} */ blurListener = (event: FocusEvent) => this._onBlur(event, element);\n    this._ngZone.runOutsideAngular(() => {\n      element.addEventListener('focus', focusListener, true);\n      element.addEventListener('blur', blurListener, true);\n    });\n\n    // Create an unlisten function for later.\n    info.unlisten = () => {\n      element.removeEventListener('focus', focusListener, true);\n      element.removeEventListener('blur', blurListener, true);\n    };\n\n    return info.subject.asObservable();\n  }\n/**\n * Stops monitoring an element and removes all focus classes.\n * @param {?} element The element to stop monitoring.\n * @return {?}\n */\nstopMonitoring(element: HTMLElement): void {\n    let /** @type {?} */ elementInfo = this._elementInfo.get(element);\n\n    if (elementInfo) {\n      elementInfo.unlisten();\n      elementInfo.subject.complete();\n\n      this._setClasses(element);\n      this._elementInfo.delete(element);\n    }\n  }\n/**\n * Focuses the element via the specified focus origin.\n * @param {?} element The element to focus.\n * @param {?} origin The focus origin.\n * @return {?}\n */\nfocusVia(element: HTMLElement, origin: FocusOrigin): void {\n    this._setOriginForCurrentEventQueue(origin);\n    element.focus();\n  }\n/**\n * Register necessary event listeners on the document and window.\n * @return {?}\n */\nprivate _registerDocumentEvents() {\n    // Do nothing if we're not on the browser platform.\n    if (!this._platform.isBrowser) {\n      return;\n    }\n\n    // Note: we listen to events in the capture phase so we can detect them even if the user stops\n    // propagation.\n\n    // On keydown record the origin and clear any touch event that may be in progress.\n    document.addEventListener('keydown', () => {\n      this._lastTouchTarget = null;\n      this._setOriginForCurrentEventQueue('keyboard');\n    }, true);\n\n    // On mousedown record the origin only if there is not touch target, since a mousedown can\n    // happen as a result of a touch event.\n    document.addEventListener('mousedown', () => {\n      if (!this._lastTouchTarget) {\n        this._setOriginForCurrentEventQueue('mouse');\n      }\n    }, true);\n\n    // When the touchstart event fires the focus event is not yet in the event queue. This means\n    // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n    // see if a focus happens.\n    document.addEventListener('touchstart', (event: Event) => {\n      if (this._touchTimeout != null) {\n        clearTimeout(this._touchTimeout);\n      }\n      this._lastTouchTarget = event.target;\n      this._touchTimeout = setTimeout(() => this._lastTouchTarget = null, TOUCH_BUFFER_MS);\n    }, true);\n\n    // Make a note of when the window regains focus, so we can restore the origin info for the\n    // focused element.\n    window.addEventListener('focus', () => {\n      this._windowFocused = true;\n      setTimeout(() => this._windowFocused = false, 0);\n    });\n  }\n/**\n * Sets the focus classes on the element based on the given focus origin.\n * @param {?} element The element to update the classes on.\n * @param {?=} origin The focus origin.\n * @return {?}\n */\nprivate _setClasses(element: HTMLElement, origin?: FocusOrigin): void {\n    const /** @type {?} */ elementInfo = this._elementInfo.get(element);\n\n    if (elementInfo) {\n      const /** @type {?} */ toggleClass = (className: string, shouldSet: boolean) => {\n        shouldSet ? elementInfo.renderer.addClass(element, className) :\n                    elementInfo.renderer.removeClass(element, className);\n      };\n\n      toggleClass('cdk-focused', !!origin);\n      toggleClass('cdk-touch-focused', origin === 'touch');\n      toggleClass('cdk-keyboard-focused', origin === 'keyboard');\n      toggleClass('cdk-mouse-focused', origin === 'mouse');\n      toggleClass('cdk-program-focused', origin === 'program');\n    }\n  }\n/**\n * Sets the origin and schedules an async function to clear it at the end of the event queue.\n * @param {?} origin The origin to set.\n * @return {?}\n */\nprivate _setOriginForCurrentEventQueue(origin: FocusOrigin): void {\n    this._origin = origin;\n    setTimeout(() => this._origin = null, 0);\n  }\n/**\n * Checks whether the given focus event was caused by a touchstart event.\n * @param {?} event The focus event to check.\n * @return {?} Whether the event was caused by a touch.\n */\nprivate _wasCausedByTouch(event: FocusEvent): boolean {\n    // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n    // Consider the following dom structure:\n    //\n    // <div #parent tabindex=\"0\" cdkFocusClasses>\n    //   <div #child (click)=\"#parent.focus()\"></div>\n    // </div>\n    //\n    // If the user touches the #child element and the #parent is programmatically focused as a\n    // result, this code will still consider it to have been caused by the touch event and will\n    // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n    // relatively small edge-case that can be worked around by using\n    // focusVia(parentEl, renderer,  'program') to focus the parent element.\n    //\n    // If we decide that we absolutely must handle this case correctly, we can do so by listening\n    // for the first focus event after the touchstart, and then the first blur event after that\n    // focus event. When that blur event fires we know that whatever follows is not a result of the\n    // touchstart.\n    let /** @type {?} */ focusTarget = event.target;\n    return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n        (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n  }\n/**\n * Handles focus events on a registered element.\n * @param {?} event The focus event.\n * @param {?} element The monitored element.\n * @return {?}\n */\nprivate _onFocus(event: FocusEvent, element: HTMLElement) {\n    // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n    // focus event affecting the monitored element. If we want to use the origin of the first event\n    // instead we should check for the cdk-focused class here and return if the element already has\n    // it. (This only matters for elements that have includesChildren = true).\n\n    // If we are not counting child-element-focus as focused, make sure that the event target is the\n    // monitored element itself.\n    const /** @type {?} */ elementInfo = this._elementInfo.get(element);\n    if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n      return;\n    }\n\n    // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n    // 1) The window has just regained focus, in which case we want to restore the focused state of\n    //    the element from before the window blurred.\n    // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n    // 3) The element was programmatically focused, in which case we should mark the origin as\n    //    'program'.\n    if (!this._origin) {\n      if (this._windowFocused && this._lastFocusOrigin) {\n        this._origin = this._lastFocusOrigin;\n      } else if (this._wasCausedByTouch(event)) {\n        this._origin = 'touch';\n      } else {\n        this._origin = 'program';\n      }\n    }\n\n    this._setClasses(element, this._origin);\n    elementInfo.subject.next(this._origin);\n    this._lastFocusOrigin = this._origin;\n    this._origin = null;\n  }\n/**\n * Handles blur events on a registered element.\n * @param {?} event The blur event.\n * @param {?} element The monitored element.\n * @return {?}\n */\n_onBlur(event: FocusEvent, element: HTMLElement) {\n    // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n    // order to focus another child of the monitored element.\n    const /** @type {?} */ elementInfo = this._elementInfo.get(element);\n\n    if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n        element.contains(event.relatedTarget))) {\n      return;\n    }\n\n    this._setClasses(element);\n    elementInfo.subject.next(null);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: NgZone, },\n{type: Platform, },\n];\n}\n\nfunction FocusOriginMonitor_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusOriginMonitor.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFocusOriginMonitor.ctorParameters;\n/**\n * The focus origin that the next focus event is a result of.\n * @type {?}\n */\nFocusOriginMonitor.prototype._origin;\n/**\n * The FocusOrigin of the last focus event tracked by the FocusOriginMonitor.\n * @type {?}\n */\nFocusOriginMonitor.prototype._lastFocusOrigin;\n/**\n * Whether the window has just been focused.\n * @type {?}\n */\nFocusOriginMonitor.prototype._windowFocused;\n/**\n * The target of the last touch event.\n * @type {?}\n */\nFocusOriginMonitor.prototype._lastTouchTarget;\n/**\n * The timeout id of the touch timeout, used to cancel timeout later.\n * @type {?}\n */\nFocusOriginMonitor.prototype._touchTimeout;\n/**\n * Weak map of elements being monitored to their info.\n * @type {?}\n */\nFocusOriginMonitor.prototype._elementInfo;\n/** @type {?} */\nFocusOriginMonitor.prototype._ngZone;\n/** @type {?} */\nFocusOriginMonitor.prototype._platform;\n}\n\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n * \n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nexport class CdkMonitorFocus implements OnDestroy {\nprivate _monitorSubscription: Subscription;\n   cdkFocusChange = new EventEmitter<FocusOrigin>();\n/**\n * @param {?} _elementRef\n * @param {?} _focusOriginMonitor\n * @param {?} renderer\n */\nconstructor(private _elementRef: ElementRef,\nprivate _focusOriginMonitor: FocusOriginMonitor,\n              renderer: Renderer2) {\n    this._monitorSubscription = this._focusOriginMonitor.monitor(\n        this._elementRef.nativeElement, renderer,\n        this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n        .subscribe(origin => this.cdkFocusChange.emit(origin));\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this._focusOriginMonitor.stopMonitoring(this._elementRef.nativeElement);\n    this._monitorSubscription.unsubscribe();\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: FocusOriginMonitor, },\n{type: Renderer2, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'cdkFocusChange': [{ type: Output },],\n};\n}\n\nfunction CdkMonitorFocus_tsickle_Closure_declarations() {\n/** @type {?} */\nCdkMonitorFocus.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nCdkMonitorFocus.ctorParameters;\n/** @type {?} */\nCdkMonitorFocus.propDecorators;\n/** @type {?} */\nCdkMonitorFocus.prototype._monitorSubscription;\n/** @type {?} */\nCdkMonitorFocus.prototype.cdkFocusChange;\n/** @type {?} */\nCdkMonitorFocus.prototype._elementRef;\n/** @type {?} */\nCdkMonitorFocus.prototype._focusOriginMonitor;\n}\n\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nexport function FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY(\n    parentDispatcher: FocusOriginMonitor, ngZone: NgZone, platform: Platform) {\n  return parentDispatcher || new FocusOriginMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nexport const FOCUS_ORIGIN_MONITOR_PROVIDER = {\n  // If there is already a FocusOriginMonitor available, use that. Otherwise, provide a new one.\n  provide: FocusOriginMonitor,\n  deps: [[new Optional(), new SkipSelf(), FocusOriginMonitor], NgZone, Platform],\n  useFactory: FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY\n};\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}