{"version":3,"sources":["../../../../../../src/lib/core/overlay/position/viewport-ruler.ts"],"names":[],"mappings":"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","file":"viewport-ruler.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Injectable, Optional, SkipSelf} from '@angular/core';\nimport {ScrollDispatcher} from '../scroll/scroll-dispatcher';\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * \\@docs-private\n */\nexport class ViewportRuler {\n/**\n * Cached document client rectangle.\n */\nprivate _documentRect?: ClientRect;\n/**\n * @param {?} scrollDispatcher\n */\nconstructor(scrollDispatcher: ScrollDispatcher) {\n    // Subscribe to scroll and resize events and update the document rectangle on changes.\n    scrollDispatcher.scrolled(0, () => this._cacheViewportGeometry());\n  }\n/**\n * Gets a ClientRect for the viewport's bounds.\n * @param {?=} documentRect\n * @return {?}\n */\ngetViewportRect(documentRect = this._documentRect): ClientRect {\n    // Cache the document bounding rect so that we don't recompute it for multiple calls.\n    if (!documentRect) {\n      this._cacheViewportGeometry();\n      documentRect = this._documentRect;\n    }\n\n    // Use the document element's bounding rect rather than the window scroll properties\n    // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n    // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n    // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n    // can disagree when the page is pinch-zoomed (on devices that support touch).\n    // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n    // We use the documentElement instead of the body because, by default (without a css reset)\n    // browsers typically give the document body an 8px margin, which is not included in\n    // getBoundingClientRect().\n    const /** @type {?} */ scrollPosition = this.getViewportScrollPosition(documentRect);\n    const /** @type {?} */ height = window.innerHeight;\n    const /** @type {?} */ width = window.innerWidth;\n\n    return {\n      top: scrollPosition.top,\n      left: scrollPosition.left,\n      bottom: scrollPosition.top + height,\n      right: scrollPosition.left + width,\n      height,\n      width,\n    };\n  }\n/**\n * Gets the (top, left) scroll position of the viewport.\n * @param {?=} documentRect\n * @return {?}\n */\ngetViewportScrollPosition(documentRect = this._documentRect) {\n    // Cache the document bounding rect so that we don't recompute it for multiple calls.\n    if (!documentRect) {\n      this._cacheViewportGeometry();\n      documentRect = this._documentRect;\n    }\n\n    // The top-left-corner of the viewport is determined by the scroll position of the document\n    // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n    // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n    // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n    // `document.documentElement` works consistently, where the `top` and `left` values will\n    // equal negative the scroll position.\n    const /** @type {?} */ top = - /** @type {?} */((documentRect)).top || document.body.scrollTop || window.scrollY ||\n                  document.documentElement.scrollTop || 0;\n\n    const /** @type {?} */ left = - /** @type {?} */((documentRect)).left || document.body.scrollLeft || window.scrollX ||\n                  document.documentElement.scrollLeft || 0;\n\n    return {top, left};\n  }\n/**\n * Caches the latest client rectangle of the document element.\n * @return {?}\n */\n_cacheViewportGeometry() {\n    this._documentRect = document.documentElement.getBoundingClientRect();\n  }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ScrollDispatcher, },\n];\n}\n\nfunction ViewportRuler_tsickle_Closure_declarations() {\n/** @type {?} */\nViewportRuler.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nViewportRuler.ctorParameters;\n/**\n * Cached document client rectangle.\n * @type {?}\n */\nViewportRuler.prototype._documentRect;\n}\n\n/**\n * \\@docs-private\n * @param {?} parentRuler\n * @param {?} scrollDispatcher\n * @return {?}\n */\nexport function VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler: ViewportRuler,\n                                                scrollDispatcher: ScrollDispatcher) {\n  return parentRuler || new ViewportRuler(scrollDispatcher);\n}\n/**\n * \\@docs-private\n */\nexport const VIEWPORT_RULER_PROVIDER = {\n  // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\n  provide: ViewportRuler,\n  deps: [[new Optional(), new SkipSelf(), ViewportRuler], ScrollDispatcher],\n  useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\n};\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}