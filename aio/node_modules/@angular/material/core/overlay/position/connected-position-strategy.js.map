{"version":3,"sources":["../../../../../../src/lib/core/overlay/position/connected-position-strategy.ts"],"names":[],"mappings":"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","file":"connected-position-strategy.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {PositionStrategy} from './position-strategy';\nimport {ElementRef} from '@angular/core';\nimport {ViewportRuler} from './viewport-ruler';\nimport {\n  ConnectionPositionPair,\n  OriginConnectionPosition,\n  OverlayConnectionPosition,\n  ConnectedOverlayPositionChange, ScrollableViewProperties\n} from './connected-position';\nimport {Subject} from 'rxjs/Subject';\nimport {Observable} from 'rxjs/Observable';\nimport {Scrollable} from '../scroll/scrollable';\n\n/**\n * Container to hold the bounding positions of a particular element with respect to the viewport,\n * where top and bottom are the y-axis coordinates of the bounding rectangle and left and right are\n * the x-axis coordinates.\n */\ntype ElementBoundingPositions = {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n};\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nexport class ConnectedPositionStrategy implements PositionStrategy {\nprivate _dir = 'ltr';\n/**\n * The offset in pixels for the overlay connection point on the x-axis\n */\nprivate _offsetX: number = 0;\n/**\n * The offset in pixels for the overlay connection point on the y-axis\n */\nprivate _offsetY: number = 0;\n/**\n * The Scrollable containers used to check scrollable view properties on position change.\n */\nprivate scrollables: Scrollable[] = [];\n/**\n * Whether the we're dealing with an RTL context\n * @return {?}\n */\nget _isRtl() {\n    return this._dir === 'rtl';\n  }\n/**\n * Ordered list of preferred positions, from most to least desirable.\n */\n_preferredPositions: ConnectionPositionPair[] = [];\n/**\n * The origin element against which the overlay will be positioned.\n */\nprivate _origin: HTMLElement;\n/**\n * The overlay pane element.\n */\nprivate _pane: HTMLElement;\n/**\n * The last position to have been calculated as the best fit position.\n */\nprivate _lastConnectedPosition: ConnectionPositionPair;\n\n  _onPositionChange:\n      Subject<ConnectedOverlayPositionChange> = new Subject<ConnectedOverlayPositionChange>();\n/**\n * Emits an event when the connection point changes.\n * @return {?}\n */\nget onPositionChange(): Observable<ConnectedOverlayPositionChange> {\n    return this._onPositionChange.asObservable();\n  }\n/**\n * @param {?} _connectedTo\n * @param {?} _originPos\n * @param {?} _overlayPos\n * @param {?} _viewportRuler\n */\nconstructor(\nprivate _connectedTo: ElementRef,\nprivate _originPos: OriginConnectionPosition,\nprivate _overlayPos: OverlayConnectionPosition,\nprivate _viewportRuler: ViewportRuler) {\n    this._origin = this._connectedTo.nativeElement;\n    this.withFallbackPosition(_originPos, _overlayPos);\n  }\n/**\n * Ordered list of preferred positions, from most to least desirable.\n * @return {?}\n */\nget positions() {\n    return this._preferredPositions;\n  }\n/**\n * To be used to for any cleanup after the element gets destroyed.\n * @return {?}\n */\ndispose() { }\n/**\n * Updates the position of the overlay element, using whichever preferred position relative\n * to the origin fits on-screen.\n * \\@docs-private \n * \n * @param {?} element Element to which to apply the CSS styles.\n * @return {?} Resolves when the styles have been applied.\n */\napply(element: HTMLElement): void {\n    // Cache the overlay pane element in case re-calculating position is necessary\n    this._pane = element;\n\n    // We need the bounding rects for the origin and the overlay to determine how to position\n    // the overlay relative to the origin.\n    const /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n    const /** @type {?} */ overlayRect = element.getBoundingClientRect();\n\n    // We use the viewport rect to determine whether a position would go off-screen.\n    const /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\n\n    // Fallback point if none of the fallbacks fit into the viewport.\n    let /** @type {?} */ fallbackPoint: OverlayPoint | undefined;\n    let /** @type {?} */ fallbackPosition: ConnectionPositionPair | undefined;\n\n    // We want to place the overlay in the first of the preferred positions such that the\n    // overlay fits on-screen.\n    for (let /** @type {?} */ pos of this._preferredPositions) {\n      // Get the (x, y) point of connection on the origin, and then use that to get the\n      // (top, left) coordinate for the overlay at `pos`.\n      let /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n      let /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, pos);\n\n      // If the overlay in the calculated position fits on-screen, put it there and we're done.\n      if (overlayPoint.fitsInViewport) {\n        this._setElementPosition(element, overlayRect, overlayPoint, pos);\n\n        // Save the last connected position in case the position needs to be re-calculated.\n        this._lastConnectedPosition = pos;\n\n        return;\n      } else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n        fallbackPoint = overlayPoint;\n        fallbackPosition = pos;\n      }\n    }\n\n    // If none of the preferred positions were in the viewport, take the one\n    // with the largest visible area.\n    this._setElementPosition(element, overlayRect, /** @type {?} */(( fallbackPoint)), /** @type {?} */(( fallbackPosition)));\n  }\n/**\n * This re-aligns the overlay element with the trigger in its last calculated position,\n * even if a position higher in the \"preferred positions\" list would now fit. This\n * allows one to re-align the panel without changing the orientation of the panel.\n * @return {?}\n */\nrecalculateLastPosition(): void {\n    const /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n    const /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n    const /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\n    const /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n\n    let /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n    let /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, lastPosition);\n    this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n  }\n/**\n * Sets the list of Scrollable containers that host the origin element so that\n * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n * Scrollable must be an ancestor element of the strategy's origin element.\n * @param {?} scrollables\n * @return {?}\n */\nwithScrollableContainers(scrollables: Scrollable[]) {\n    this.scrollables = scrollables;\n  }\n/**\n * Adds a new preferred fallback position.\n * @param {?} originPos\n * @param {?} overlayPos\n * @return {?}\n */\nwithFallbackPosition(\n      originPos: OriginConnectionPosition,\n      overlayPos: OverlayConnectionPosition): this {\n    this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));\n    return this;\n  }\n/**\n * Sets the layout direction so the overlay's position can be adjusted to match.\n * @param {?} dir New layout direction.\n * @return {?}\n */\nwithDirection(dir: 'ltr' | 'rtl'): this {\n    this._dir = dir;\n    return this;\n  }\n/**\n * Sets an offset for the overlay's connection point on the x-axis\n * @param {?} offset New offset in the X axis.\n * @return {?}\n */\nwithOffsetX(offset: number): this {\n    this._offsetX = offset;\n    return this;\n  }\n/**\n * Sets an offset for the overlay's connection point on the y-axis\n * @param {?} offset New offset in the Y axis.\n * @return {?}\n */\nwithOffsetY(offset: number): this {\n    this._offsetY = offset;\n    return this;\n  }\n/**\n * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n * @param {?} rect\n * @return {?}\n */\nprivate _getStartX(rect: ClientRect): number {\n    return this._isRtl ? rect.right : rect.left;\n  }\n/**\n * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n * @param {?} rect\n * @return {?}\n */\nprivate _getEndX(rect: ClientRect): number {\n    return this._isRtl ? rect.left : rect.right;\n  }\n/**\n * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n * @param {?} originRect\n * @param {?} pos\n * @return {?}\n */\nprivate _getOriginConnectionPoint(originRect: ClientRect, pos: ConnectionPositionPair): Point {\n    const /** @type {?} */ originStartX = this._getStartX(originRect);\n    const /** @type {?} */ originEndX = this._getEndX(originRect);\n\n    let /** @type {?} */ x: number;\n    if (pos.originX == 'center') {\n      x = originStartX + (originRect.width / 2);\n    } else {\n      x = pos.originX == 'start' ? originStartX : originEndX;\n    }\n\n    let /** @type {?} */ y: number;\n    if (pos.originY == 'center') {\n      y = originRect.top + (originRect.height / 2);\n    } else {\n      y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n    }\n\n    return {x, y};\n  }\n/**\n * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n * origin point to which the overlay should be connected, as well as how much of the element\n * would be inside the viewport at that position.\n * @param {?} originPoint\n * @param {?} overlayRect\n * @param {?} viewportRect\n * @param {?} pos\n * @return {?}\n */\nprivate _getOverlayPoint(\n      originPoint: Point,\n      overlayRect: ClientRect,\n      viewportRect: ClientRect,\n      pos: ConnectionPositionPair): OverlayPoint {\n    // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n    // relative to the origin point.\n    let /** @type {?} */ overlayStartX: number;\n    if (pos.overlayX == 'center') {\n      overlayStartX = -overlayRect.width / 2;\n    } else if (pos.overlayX === 'start') {\n      overlayStartX = this._isRtl ? -overlayRect.width : 0;\n    } else {\n      overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n    }\n\n    let /** @type {?} */ overlayStartY: number;\n    if (pos.overlayY == 'center') {\n      overlayStartY = -overlayRect.height / 2;\n    } else {\n      overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n    }\n\n    // The (x, y) coordinates of the overlay.\n    let /** @type {?} */ x = originPoint.x + overlayStartX + this._offsetX;\n    let /** @type {?} */ y = originPoint.y + overlayStartY + this._offsetY;\n\n    // How much the overlay would overflow at this position, on each side.\n    let /** @type {?} */ leftOverflow = 0 - x;\n    let /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportRect.width;\n    let /** @type {?} */ topOverflow = 0 - y;\n    let /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportRect.height;\n\n    // Visible parts of the element on each axis.\n    let /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n    let /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n\n    // The area of the element that's within the viewport.\n    let /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n    let /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n\n    return {x, y, fitsInViewport, visibleArea};\n  }\n/**\n * Gets the view properties of the trigger and overlay, including whether they are clipped\n * or completely outside the view of any of the strategy's scrollables.\n * @param {?} overlay\n * @return {?}\n */\nprivate getScrollableViewProperties(overlay: HTMLElement): ScrollableViewProperties {\n    const /** @type {?} */ originBounds = this._getElementBounds(this._origin);\n    const /** @type {?} */ overlayBounds = this._getElementBounds(overlay);\n    const /** @type {?} */ scrollContainerBounds = this.scrollables.map((scrollable: Scrollable) => {\n      return this._getElementBounds(scrollable.getElementRef().nativeElement);\n    });\n\n    return {\n      isOriginClipped: this.isElementClipped(originBounds, scrollContainerBounds),\n      isOriginOutsideView: this.isElementOutsideView(originBounds, scrollContainerBounds),\n      isOverlayClipped: this.isElementClipped(overlayBounds, scrollContainerBounds),\n      isOverlayOutsideView: this.isElementOutsideView(overlayBounds, scrollContainerBounds),\n    };\n  }\n/**\n * Whether the element is completely out of the view of any of the containers.\n * @param {?} elementBounds\n * @param {?} containersBounds\n * @return {?}\n */\nprivate isElementOutsideView(\n      elementBounds: ElementBoundingPositions,\n      containersBounds: ElementBoundingPositions[]): boolean {\n    return containersBounds.some((containerBounds: ElementBoundingPositions) => {\n      const /** @type {?} */ outsideAbove = elementBounds.bottom < containerBounds.top;\n      const /** @type {?} */ outsideBelow = elementBounds.top > containerBounds.bottom;\n      const /** @type {?} */ outsideLeft = elementBounds.right < containerBounds.left;\n      const /** @type {?} */ outsideRight = elementBounds.left > containerBounds.right;\n\n      return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n  }\n/**\n * Whether the element is clipped by any of the containers.\n * @param {?} elementBounds\n * @param {?} containersBounds\n * @return {?}\n */\nprivate isElementClipped(\n      elementBounds: ElementBoundingPositions,\n      containersBounds: ElementBoundingPositions[]): boolean {\n    return containersBounds.some((containerBounds: ElementBoundingPositions) => {\n      const /** @type {?} */ clippedAbove = elementBounds.top < containerBounds.top;\n      const /** @type {?} */ clippedBelow = elementBounds.bottom > containerBounds.bottom;\n      const /** @type {?} */ clippedLeft = elementBounds.left < containerBounds.left;\n      const /** @type {?} */ clippedRight = elementBounds.right > containerBounds.right;\n\n      return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n  }\n/**\n * Physically positions the overlay element to the given coordinate.\n * @param {?} element\n * @param {?} overlayRect\n * @param {?} overlayPoint\n * @param {?} pos\n * @return {?}\n */\nprivate _setElementPosition(\n      element: HTMLElement,\n      overlayRect: ClientRect,\n      overlayPoint: Point,\n      pos: ConnectionPositionPair) {\n\n    // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n    // or below the origin and the direction in which the element will expand.\n    let /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n\n    // When using `bottom`, we adjust the y position such that it is the distance\n    // from the bottom of the viewport rather than the top.\n    let /** @type {?} */ y = verticalStyleProperty === 'top' ?\n        overlayPoint.y :\n        document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n\n    // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n    // or \"after\" the origin, which determines the direction in which the element will expand.\n    // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n    // page is in RTL or LTR.\n    let /** @type {?} */ horizontalStyleProperty: string;\n    if (this._dir === 'rtl') {\n      horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n    } else {\n      horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n    }\n\n    // When we're setting `right`, we adjust the x position such that it is the distance\n    // from the right edge of the viewport rather than the left edge.\n    let /** @type {?} */ x = horizontalStyleProperty === 'left' ?\n      overlayPoint.x :\n      document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n\n\n    // Reset any existing styles. This is necessary in case the preferred position has\n    // changed since the last `apply`.\n    ['top', 'bottom', 'left', 'right'].forEach(p => element.style[p] = null);\n\n    element.style[verticalStyleProperty] = `${y}px`;\n    element.style[horizontalStyleProperty] = `${x}px`;\n\n    // Notify that the position has been changed along with its change properties.\n    const /** @type {?} */ scrollableViewProperties = this.getScrollableViewProperties(element);\n    const /** @type {?} */ positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n    this._onPositionChange.next(positionChange);\n  }\n/**\n * Returns the bounding positions of the provided element with respect to the viewport.\n * @param {?} element\n * @return {?}\n */\nprivate _getElementBounds(element: HTMLElement): ElementBoundingPositions {\n    const /** @type {?} */ boundingClientRect = element.getBoundingClientRect();\n    return {\n      top: boundingClientRect.top,\n      right: boundingClientRect.left + boundingClientRect.width,\n      bottom: boundingClientRect.top + boundingClientRect.height,\n      left: boundingClientRect.left\n    };\n  }\n/**\n * Subtracts the amount that an element is overflowing on an axis from it's length.\n * @param {?} length\n * @param {...?} overflows\n * @return {?}\n */\nprivate _subtractOverflows(length: number, ...overflows: number[]): number {\n    return overflows.reduce((currentValue: number, currentOverflow: number) => {\n      return currentValue - Math.max(currentOverflow, 0);\n    }, length);\n  }\n}\n\nfunction ConnectedPositionStrategy_tsickle_Closure_declarations() {\n/** @type {?} */\nConnectedPositionStrategy.prototype._dir;\n/**\n * The offset in pixels for the overlay connection point on the x-axis\n * @type {?}\n */\nConnectedPositionStrategy.prototype._offsetX;\n/**\n * The offset in pixels for the overlay connection point on the y-axis\n * @type {?}\n */\nConnectedPositionStrategy.prototype._offsetY;\n/**\n * The Scrollable containers used to check scrollable view properties on position change.\n * @type {?}\n */\nConnectedPositionStrategy.prototype.scrollables;\n/**\n * Ordered list of preferred positions, from most to least desirable.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._preferredPositions;\n/**\n * The origin element against which the overlay will be positioned.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._origin;\n/**\n * The overlay pane element.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._pane;\n/**\n * The last position to have been calculated as the best fit position.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._lastConnectedPosition;\n/** @type {?} */\nConnectedPositionStrategy.prototype._onPositionChange;\n/** @type {?} */\nConnectedPositionStrategy.prototype._connectedTo;\n/** @type {?} */\nConnectedPositionStrategy.prototype._originPos;\n/** @type {?} */\nConnectedPositionStrategy.prototype._overlayPos;\n/** @type {?} */\nConnectedPositionStrategy.prototype._viewportRuler;\n}\n\n\n/** A simple (x, y) coordinate. */\ninterface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * Expands the simple (x, y) coordinate by adding info about whether the\n * element would fit inside the viewport at that position, as well as\n * how much of the element would be visible.\n */\ninterface OverlayPoint extends Point {\n  visibleArea: number;\n  fitsInViewport: boolean;\n}\n"]}