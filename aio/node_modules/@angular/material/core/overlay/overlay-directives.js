/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directive, EventEmitter, TemplateRef, ViewContainerRef, Optional, Input, Output, ElementRef, Renderer2, InjectionToken, Inject, } from '@angular/core';
import { Overlay } from './overlay';
import { TemplatePortal } from '../portal/portal';
import { OverlayState } from './overlay-state';
import { ConnectionPositionPair } from './position/connected-position';
import { Directionality } from '../bidi/index';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ESCAPE } from '../keyboard/keycodes';
/**
 * Default set of positions for the overlay. Follows the behavior of a dropdown.
 */
var defaultPositionList = [
    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
];
/**
 * Injection token that determines the scroll handling while the connected overlay is open.
 */
export var MD_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken('md-connected-overlay-scroll-strategy');
/**
 * \@docs-private
 * @param {?} overlay
 * @return {?}
 */
export function MD_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return function () { return overlay.scrollStrategies.reposition(); };
}
/**
 * \@docs-private
 */
export var MD_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {
    provide: MD_CONNECTED_OVERLAY_SCROLL_STRATEGY,
    deps: [Overlay],
    useFactory: MD_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,
};
/**
 * Directive applied to an element to make it usable as an origin for an Overlay using a
 * ConnectedPositionStrategy.
 */
var OverlayOrigin = (function () {
    /**
     * @param {?} elementRef
     */
    function OverlayOrigin(elementRef) {
        this.elementRef = elementRef;
    }
    return OverlayOrigin;
}());
export { OverlayOrigin };
OverlayOrigin.decorators = [
    { type: Directive, args: [{
                selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',
                exportAs: 'cdkOverlayOrigin',
            },] },
];
/**
 * @nocollapse
 */
OverlayOrigin.ctorParameters = function () { return [
    { type: ElementRef, },
]; };
function OverlayOrigin_tsickle_Closure_declarations() {
    /** @type {?} */
    OverlayOrigin.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    OverlayOrigin.ctorParameters;
    /** @type {?} */
    OverlayOrigin.prototype.elementRef;
}
/**
 * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.
 */
var ConnectedOverlayDirective = (function () {
    /**
     * @param {?} _overlay
     * @param {?} _renderer
     * @param {?} templateRef
     * @param {?} viewContainerRef
     * @param {?} _scrollStrategy
     * @param {?} _dir
     */
    function ConnectedOverlayDirective(_overlay, _renderer, templateRef, viewContainerRef, _scrollStrategy, _dir) {
        this._overlay = _overlay;
        this._renderer = _renderer;
        this._scrollStrategy = _scrollStrategy;
        this._dir = _dir;
        this._hasBackdrop = false;
        this._offsetX = 0;
        this._offsetY = 0;
        /**
         * Strategy to be used when handling scroll events while the overlay is open.
         */
        this.scrollStrategy = this._scrollStrategy();
        /**
         * Whether the overlay is open.
         */
        this.open = false;
        /**
         * Event emitted when the backdrop is clicked.
         */
        this.backdropClick = new EventEmitter();
        /**
         * Event emitted when the position has changed.
         */
        this.positionChange = new EventEmitter();
        /**
         * Event emitted when the overlay has been attached.
         */
        this.attach = new EventEmitter();
        /**
         * Event emitted when the overlay has been detached.
         */
        this.detach = new EventEmitter();
        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);
    }
    Object.defineProperty(ConnectedOverlayDirective.prototype, "offsetX", {
        /**
         * The offset in pixels for the overlay connection point on the x-axis
         * @return {?}
         */
        get: function () { return this._offsetX; },
        /**
         * @param {?} offsetX
         * @return {?}
         */
        set: function (offsetX) {
            this._offsetX = offsetX;
            if (this._position) {
                this._position.withOffsetX(offsetX);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "offsetY", {
        /**
         * The offset in pixels for the overlay connection point on the y-axis
         * @return {?}
         */
        get: function () { return this._offsetY; },
        /**
         * @param {?} offsetY
         * @return {?}
         */
        set: function (offsetY) {
            this._offsetY = offsetY;
            if (this._position) {
                this._position.withOffsetY(offsetY);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "hasBackdrop", {
        /**
         * Whether or not the overlay should attach a backdrop.
         * @return {?}
         */
        get: function () { return this._hasBackdrop; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) { this._hasBackdrop = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "_deprecatedOrigin", {
        /**
         * @deprecated
         * @return {?}
         */
        get: function () { return this.origin; },
        /**
         * @param {?} _origin
         * @return {?}
         */
        set: function (_origin) { this.origin = _origin; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "_deprecatedPositions", {
        /**
         * @deprecated
         * @return {?}
         */
        get: function () { return this.positions; },
        /**
         * @param {?} _positions
         * @return {?}
         */
        set: function (_positions) { this.positions = _positions; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "_deprecatedOffsetX", {
        /**
         * @deprecated
         * @return {?}
         */
        get: function () { return this.offsetX; },
        /**
         * @param {?} _offsetX
         * @return {?}
         */
        set: function (_offsetX) { this.offsetX = _offsetX; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "_deprecatedOffsetY", {
        /**
         * @deprecated
         * @return {?}
         */
        get: function () { return this.offsetY; },
        /**
         * @param {?} _offsetY
         * @return {?}
         */
        set: function (_offsetY) { this.offsetY = _offsetY; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "_deprecatedWidth", {
        /**
         * @deprecated
         * @return {?}
         */
        get: function () { return this.width; },
        /**
         * @param {?} _width
         * @return {?}
         */
        set: function (_width) { this.width = _width; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "_deprecatedHeight", {
        /**
         * @deprecated
         * @return {?}
         */
        get: function () { return this.height; },
        /**
         * @param {?} _height
         * @return {?}
         */
        set: function (_height) { this.height = _height; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "_deprecatedMinWidth", {
        /**
         * @deprecated
         * @return {?}
         */
        get: function () { return this.minWidth; },
        /**
         * @param {?} _minWidth
         * @return {?}
         */
        set: function (_minWidth) { this.minWidth = _minWidth; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "_deprecatedMinHeight", {
        /**
         * @deprecated
         * @return {?}
         */
        get: function () { return this.minHeight; },
        /**
         * @param {?} _minHeight
         * @return {?}
         */
        set: function (_minHeight) { this.minHeight = _minHeight; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "_deprecatedBackdropClass", {
        /**
         * @deprecated
         * @return {?}
         */
        get: function () { return this.backdropClass; },
        /**
         * @param {?} _backdropClass
         * @return {?}
         */
        set: function (_backdropClass) { this.backdropClass = _backdropClass; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "_deprecatedScrollStrategy", {
        /**
         * @deprecated
         * @return {?}
         */
        get: function () { return this.scrollStrategy; },
        /**
         * @param {?} _scrollStrategy
         * @return {?}
         */
        set: function (_scrollStrategy) {
            this.scrollStrategy = _scrollStrategy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "_deprecatedOpen", {
        /**
         * @deprecated
         * @return {?}
         */
        get: function () { return this.open; },
        /**
         * @param {?} _open
         * @return {?}
         */
        set: function (_open) { this.open = _open; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "_deprecatedHasBackdrop", {
        /**
         * @deprecated
         * @return {?}
         */
        get: function () { return this.hasBackdrop; },
        /**
         * @param {?} _hasBackdrop
         * @return {?}
         */
        set: function (_hasBackdrop) { this.hasBackdrop = _hasBackdrop; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "overlayRef", {
        /**
         * The associated overlay reference.
         * @return {?}
         */
        get: function () {
            return this._overlayRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedOverlayDirective.prototype, "dir", {
        /**
         * The element's layout direction.
         * @return {?}
         */
        get: function () {
            return this._dir ? this._dir.value : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ConnectedOverlayDirective.prototype.ngOnDestroy = function () {
        this._destroyOverlay();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    ConnectedOverlayDirective.prototype.ngOnChanges = function (changes) {
        if (changes['open'] || changes['_deprecatedOpen']) {
            this.open ? this._attachOverlay() : this._detachOverlay();
        }
    };
    /**
     * Creates an overlay
     * @return {?}
     */
    ConnectedOverlayDirective.prototype._createOverlay = function () {
        if (!this.positions || !this.positions.length) {
            this.positions = defaultPositionList;
        }
        this._overlayRef = this._overlay.create(this._buildConfig());
    };
    /**
     * Builds the overlay config based on the directive's inputs
     * @return {?}
     */
    ConnectedOverlayDirective.prototype._buildConfig = function () {
        var /** @type {?} */ overlayConfig = new OverlayState();
        if (this.width || this.width === 0) {
            overlayConfig.width = this.width;
        }
        if (this.height || this.height === 0) {
            overlayConfig.height = this.height;
        }
        if (this.minWidth || this.minWidth === 0) {
            overlayConfig.minWidth = this.minWidth;
        }
        if (this.minHeight || this.minHeight === 0) {
            overlayConfig.minHeight = this.minHeight;
        }
        overlayConfig.hasBackdrop = this.hasBackdrop;
        if (this.backdropClass) {
            overlayConfig.backdropClass = this.backdropClass;
        }
        this._position = (this._createPositionStrategy());
        overlayConfig.positionStrategy = this._position;
        overlayConfig.scrollStrategy = this.scrollStrategy;
        return overlayConfig;
    };
    /**
     * Returns the position strategy of the overlay to be set on the overlay config
     * @return {?}
     */
    ConnectedOverlayDirective.prototype._createPositionStrategy = function () {
        var /** @type {?} */ pos = this.positions[0];
        var /** @type {?} */ originPoint = { originX: pos.originX, originY: pos.originY };
        var /** @type {?} */ overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };
        var /** @type {?} */ strategy = this._overlay.position()
            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)
            .withOffsetX(this.offsetX)
            .withOffsetY(this.offsetY);
        this._handlePositionChanges(strategy);
        return strategy;
    };
    /**
     * @param {?} strategy
     * @return {?}
     */
    ConnectedOverlayDirective.prototype._handlePositionChanges = function (strategy) {
        var _this = this;
        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {
            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });
        }
        this._positionSubscription =
            strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });
    };
    /**
     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists
     * @return {?}
     */
    ConnectedOverlayDirective.prototype._attachOverlay = function () {
        var _this = this;
        if (!this._overlayRef) {
            this._createOverlay();
        }
        this._position.withDirection(this.dir);
        this._overlayRef.getState().direction = this.dir;
        this._initEscapeListener();
        if (!this._overlayRef.hasAttached()) {
            this._overlayRef.attach(this._templatePortal);
            this.attach.emit();
        }
        if (this.hasBackdrop) {
            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {
                _this.backdropClick.emit();
            });
        }
    };
    /**
     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists
     * @return {?}
     */
    ConnectedOverlayDirective.prototype._detachOverlay = function () {
        if (this._overlayRef) {
            this._overlayRef.detach();
            this.detach.emit();
        }
        if (this._backdropSubscription) {
            this._backdropSubscription.unsubscribe();
            this._backdropSubscription = null;
        }
        if (this._escapeListener) {
            this._escapeListener();
        }
    };
    /**
     * Destroys the overlay created by this directive.
     * @return {?}
     */
    ConnectedOverlayDirective.prototype._destroyOverlay = function () {
        if (this._overlayRef) {
            this._overlayRef.dispose();
        }
        if (this._backdropSubscription) {
            this._backdropSubscription.unsubscribe();
        }
        if (this._positionSubscription) {
            this._positionSubscription.unsubscribe();
        }
        if (this._escapeListener) {
            this._escapeListener();
        }
    };
    /**
     * Sets the event listener that closes the overlay when pressing Escape.
     * @return {?}
     */
    ConnectedOverlayDirective.prototype._initEscapeListener = function () {
        var _this = this;
        this._escapeListener = this._renderer.listen('document', 'keydown', function (event) {
            if (event.keyCode === ESCAPE) {
                _this._detachOverlay();
            }
        });
    };
    return ConnectedOverlayDirective;
}());
export { ConnectedOverlayDirective };
ConnectedOverlayDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',
                exportAs: 'cdkConnectedOverlay'
            },] },
];
/**
 * @nocollapse
 */
ConnectedOverlayDirective.ctorParameters = function () { return [
    { type: Overlay, },
    { type: Renderer2, },
    { type: TemplateRef, },
    { type: ViewContainerRef, },
    { type: undefined, decorators: [{ type: Inject, args: [MD_CONNECTED_OVERLAY_SCROLL_STRATEGY,] },] },
    { type: Directionality, decorators: [{ type: Optional },] },
]; };
ConnectedOverlayDirective.propDecorators = {
    'origin': [{ type: Input, args: ['cdkConnectedOverlayOrigin',] },],
    'positions': [{ type: Input, args: ['cdkConnectedOverlayPositions',] },],
    'offsetX': [{ type: Input, args: ['cdkConnectedOverlayOffsetX',] },],
    'offsetY': [{ type: Input, args: ['cdkConnectedOverlayOffsetY',] },],
    'width': [{ type: Input, args: ['cdkConnectedOverlayWidth',] },],
    'height': [{ type: Input, args: ['cdkConnectedOverlayHeight',] },],
    'minWidth': [{ type: Input, args: ['cdkConnectedOverlayMinWidth',] },],
    'minHeight': [{ type: Input, args: ['cdkConnectedOverlayMinHeight',] },],
    'backdropClass': [{ type: Input, args: ['cdkConnectedOverlayBackdropClass',] },],
    'scrollStrategy': [{ type: Input, args: ['cdkConnectedOverlayScrollStrategy',] },],
    'open': [{ type: Input, args: ['cdkConnectedOverlayOpen',] },],
    'hasBackdrop': [{ type: Input, args: ['cdkConnectedOverlayHasBackdrop',] },],
    '_deprecatedOrigin': [{ type: Input, args: ['origin',] },],
    '_deprecatedPositions': [{ type: Input, args: ['positions',] },],
    '_deprecatedOffsetX': [{ type: Input, args: ['offsetX',] },],
    '_deprecatedOffsetY': [{ type: Input, args: ['offsetY',] },],
    '_deprecatedWidth': [{ type: Input, args: ['width',] },],
    '_deprecatedHeight': [{ type: Input, args: ['height',] },],
    '_deprecatedMinWidth': [{ type: Input, args: ['minWidth',] },],
    '_deprecatedMinHeight': [{ type: Input, args: ['minHeight',] },],
    '_deprecatedBackdropClass': [{ type: Input, args: ['backdropClass',] },],
    '_deprecatedScrollStrategy': [{ type: Input, args: ['scrollStrategy',] },],
    '_deprecatedOpen': [{ type: Input, args: ['open',] },],
    '_deprecatedHasBackdrop': [{ type: Input, args: ['hasBackdrop',] },],
    'backdropClick': [{ type: Output },],
    'positionChange': [{ type: Output },],
    'attach': [{ type: Output },],
    'detach': [{ type: Output },],
};
function ConnectedOverlayDirective_tsickle_Closure_declarations() {
    /** @type {?} */
    ConnectedOverlayDirective.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    ConnectedOverlayDirective.ctorParameters;
    /** @type {?} */
    ConnectedOverlayDirective.propDecorators;
    /** @type {?} */
    ConnectedOverlayDirective.prototype._overlayRef;
    /** @type {?} */
    ConnectedOverlayDirective.prototype._templatePortal;
    /** @type {?} */
    ConnectedOverlayDirective.prototype._hasBackdrop;
    /** @type {?} */
    ConnectedOverlayDirective.prototype._backdropSubscription;
    /** @type {?} */
    ConnectedOverlayDirective.prototype._positionSubscription;
    /** @type {?} */
    ConnectedOverlayDirective.prototype._offsetX;
    /** @type {?} */
    ConnectedOverlayDirective.prototype._offsetY;
    /** @type {?} */
    ConnectedOverlayDirective.prototype._position;
    /** @type {?} */
    ConnectedOverlayDirective.prototype._escapeListener;
    /**
     * Origin for the connected overlay.
     * @type {?}
     */
    ConnectedOverlayDirective.prototype.origin;
    /**
     * Registered connected position pairs.
     * @type {?}
     */
    ConnectedOverlayDirective.prototype.positions;
    /**
     * The width of the overlay panel.
     * @type {?}
     */
    ConnectedOverlayDirective.prototype.width;
    /**
     * The height of the overlay panel.
     * @type {?}
     */
    ConnectedOverlayDirective.prototype.height;
    /**
     * The min width of the overlay panel.
     * @type {?}
     */
    ConnectedOverlayDirective.prototype.minWidth;
    /**
     * The min height of the overlay panel.
     * @type {?}
     */
    ConnectedOverlayDirective.prototype.minHeight;
    /**
     * The custom class to be set on the backdrop element.
     * @type {?}
     */
    ConnectedOverlayDirective.prototype.backdropClass;
    /**
     * Strategy to be used when handling scroll events while the overlay is open.
     * @type {?}
     */
    ConnectedOverlayDirective.prototype.scrollStrategy;
    /**
     * Whether the overlay is open.
     * @type {?}
     */
    ConnectedOverlayDirective.prototype.open;
    /**
     * Event emitted when the backdrop is clicked.
     * @type {?}
     */
    ConnectedOverlayDirective.prototype.backdropClick;
    /**
     * Event emitted when the position has changed.
     * @type {?}
     */
    ConnectedOverlayDirective.prototype.positionChange;
    /**
     * Event emitted when the overlay has been attached.
     * @type {?}
     */
    ConnectedOverlayDirective.prototype.attach;
    /**
     * Event emitted when the overlay has been detached.
     * @type {?}
     */
    ConnectedOverlayDirective.prototype.detach;
    /** @type {?} */
    ConnectedOverlayDirective.prototype._overlay;
    /** @type {?} */
    ConnectedOverlayDirective.prototype._renderer;
    /** @type {?} */
    ConnectedOverlayDirective.prototype._scrollStrategy;
    /** @type {?} */
    ConnectedOverlayDirective.prototype._dir;
}
//# sourceMappingURL=overlay-directives.js.map