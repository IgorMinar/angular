{"version":3,"sources":["../../../../src/lib/chips/chip-list.ts"],"names":[],"mappings":"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","file":"chip-list.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  Component,\n  ContentChildren,\n  Input,\n  QueryList,\n  ViewEncapsulation,\n  OnDestroy,\n  Optional,\n  ElementRef,\n  Renderer2,\n} from '@angular/core';\n\nimport {MdChip} from './chip';\nimport {FocusKeyManager} from '../core/a11y/focus-key-manager';\nimport {BACKSPACE, DELETE, LEFT_ARROW, RIGHT_ARROW, UP_ARROW} from '../core/keyboard/keycodes';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {Subscription} from 'rxjs/Subscription';\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\n/**\n * A material design chips component (named ChipList for it's similarity to the List component).\n * \n * Example:\n * \n *     <md-chip-list>\n *       <md-chip>Chip 1<md-chip>\n *       <md-chip>Chip 2<md-chip>\n *     </md-chip-list>\n */\nexport class MdChipList implements AfterContentInit, OnDestroy {\n/**\n * When a chip is destroyed, we track the index so we can focus the appropriate next chip.\n */\nprotected _lastDestroyedIndex: number|null = null;\n/**\n * Track which chips we're listening to for focus/destruction.\n */\nprotected _chipSet: WeakMap<MdChip, boolean> = new WeakMap();\n/**\n * Subscription to tabbing out from the chip list.\n */\nprivate _tabOutSubscription: Subscription;\n/**\n * Whether or not the chip is selectable.\n */\nprotected _selectable: boolean = true;\n\n  protected _inputElement: HTMLInputElement;\n/**\n * Tab index for the chip list.\n */\n_tabIndex = 0;\n/**\n * The FocusKeyManager which handles focus.\n */\n_keyManager: FocusKeyManager;\n/**\n * The chip components contained within this chip list.\n */\nchips: QueryList<MdChip>;\n/**\n * @param {?} _renderer\n * @param {?} _elementRef\n * @param {?} _dir\n */\nconstructor(protected _renderer: Renderer2, protected _elementRef: ElementRef,\nprivate _dir: Directionality) {\n  }\n/**\n * @return {?}\n */\nngAfterContentInit(): void {\n    this._keyManager = new FocusKeyManager(this.chips).withWrap();\n\n    // Prevents the chip list from capturing focus and redirecting\n    // it back to the first chip when the user tabs out.\n    this._tabOutSubscription = this._keyManager.tabOut.subscribe(() => {\n      this._tabIndex = -1;\n      setTimeout(() => this._tabIndex = 0);\n    });\n\n    // Go ahead and subscribe all of the initial chips\n    this._subscribeChips(this.chips);\n\n    // Make sure we set our tab index at the start\n    this._updateTabIndex();\n\n    // When the list changes, re-subscribe\n    this.chips.changes.subscribe((chips: QueryList<MdChip>) => {\n      this._subscribeChips(chips);\n\n      // If we have 0 chips, attempt to focus an input (if available)\n      if (chips.length === 0) {\n        this._focusInput();\n      }\n\n      // Check to see if we need to update our tab index\n      this._updateTabIndex();\n\n      // Check to see if we have a destroyed chip and need to refocus\n      this._updateFocusForDestroyedChips();\n    });\n  }\n/**\n * @return {?}\n */\nngOnDestroy(): void {\n    if (this._tabOutSubscription) {\n      this._tabOutSubscription.unsubscribe();\n    }\n  }\n/**\n * Whether or not this chip is selectable. When a chip is not selectable,\n * it's selected state is always ignored.\n * @return {?}\n */\nget selectable(): boolean {\n    return this._selectable;\n  }\n/**\n * @param {?} value\n * @return {?}\n */\nset selectable(value: boolean) {\n    this._selectable = coerceBooleanProperty(value);\n  }\n/**\n * Associates an HTML input element with this chip list.\n * @param {?} inputElement\n * @return {?}\n */\nregisterInput(inputElement: HTMLInputElement) {\n    this._inputElement = inputElement;\n  }\n/**\n * Focuses the the first non-disabled chip in this chip list, or the associated input when there\n * are no eligible chips.\n * @return {?}\n */\nfocus() {\n    // TODO: ARIA says this should focus the first `selected` chip if any are selected.\n    if (this.chips.length > 0) {\n      this._keyManager.setFirstItemActive();\n    } else {\n      this._focusInput();\n    }\n  }\n/**\n * Attempt to focus an input if we have one.\n * @return {?}\n */\n_focusInput() {\n    if (this._inputElement) {\n      this._inputElement.focus();\n    }\n  }\n/**\n * Pass events to the keyboard manager. Available here for tests.\n * @param {?} event\n * @return {?}\n */\n_keydown(event: KeyboardEvent) {\n    let /** @type {?} */ code = event.keyCode;\n    let /** @type {?} */ target = /** @type {?} */(( event.target as HTMLElement));\n    let /** @type {?} */ isInputEmpty = this._isInputEmpty(target);\n    let /** @type {?} */ isRtl = this._dir && this._dir.value == 'rtl';\n\n    let /** @type {?} */ isPrevKey = (code === (isRtl ? RIGHT_ARROW : LEFT_ARROW));\n    let /** @type {?} */ isNextKey = (code === (isRtl ? LEFT_ARROW : RIGHT_ARROW));\n    let /** @type {?} */ isBackKey = (code === BACKSPACE || code == DELETE || code == UP_ARROW || isPrevKey);\n    // If they are on an empty input and hit backspace/delete/left arrow, focus the last chip\n    if (isInputEmpty && isBackKey) {\n      this._keyManager.setLastItemActive();\n      event.preventDefault();\n      return;\n    }\n\n    // If they are on a chip, check for space/left/right, otherwise pass to our key manager (like\n    // up/down keys)\n    if (target && target.classList.contains('mat-chip')) {\n      if (isPrevKey) {\n        this._keyManager.setPreviousItemActive();\n        event.preventDefault();\n      } else if (isNextKey) {\n        this._keyManager.setNextItemActive();\n        event.preventDefault();\n      } else {\n        this._keyManager.onKeydown(event);\n      }\n    }\n  }\n/**\n * Iterate through the list of chips and add them to our list of\n * subscribed chips.\n * \n * @param {?} chips The list of chips to be subscribed.\n * @return {?}\n */\nprotected _subscribeChips(chips: QueryList<MdChip>): void {\n    chips.forEach(chip => this._addChip(chip));\n  }\n/**\n * Check the tab index as you should not be allowed to focus an empty list.\n * @return {?}\n */\nprotected _updateTabIndex(): void {\n    // If we have 0 chips, we should not allow keyboard focus\n    this._tabIndex = (this.chips.length === 0 ? -1 : 0);\n  }\n/**\n * Add a specific chip to our subscribed list. If the chip has\n * already been subscribed, this ensures it is only subscribed\n * once.\n * \n * @param {?} chip The chip to be subscribed (or checked for existing\n * subscription).\n * @return {?}\n */\nprotected _addChip(chip: MdChip) {\n    // If we've already been subscribed to a parent, do nothing\n    if (this._chipSet.has(chip)) {\n      return;\n    }\n\n    // Watch for focus events outside of the keyboard navigation\n    chip.onFocus.subscribe(() => {\n      let /** @type {?} */ chipIndex: number = this.chips.toArray().indexOf(chip);\n\n      if (this._isValidIndex(chipIndex)) {\n        this._keyManager.updateActiveItemIndex(chipIndex);\n      }\n    });\n\n    // On destroy, remove the item from our list, and setup our destroyed focus check\n    chip.destroy.subscribe(() => {\n      let /** @type {?} */ chipIndex: number = this.chips.toArray().indexOf(chip);\n      if (this._isValidIndex(chipIndex)) {\n        if (chip._hasFocus) {\n          // Check whether the chip is the last item\n          if (chipIndex < this.chips.length - 1) {\n            this._keyManager.setActiveItem(chipIndex);\n          } else if (chipIndex - 1 >= 0) {\n            this._keyManager.setActiveItem(chipIndex - 1);\n          }\n        }\n        if (this._keyManager.activeItemIndex === chipIndex) {\n          this._lastDestroyedIndex = chipIndex;\n        }\n\n      }\n\n      this._chipSet.delete(chip);\n      chip.destroy.unsubscribe();\n    });\n\n    this._chipSet.set(chip, true);\n  }\n/**\n * Checks to see if a focus chip was recently destroyed so that we can refocus the next closest\n * one.\n * @return {?}\n */\nprotected _updateFocusForDestroyedChips() {\n    let /** @type {?} */ chipsArray = this.chips;\n\n    if (this._lastDestroyedIndex != null && chipsArray.length > 0) {\n      // Check whether the destroyed chip was the last item\n      const /** @type {?} */ newFocusIndex = Math.min(this._lastDestroyedIndex, chipsArray.length - 1);\n      this._keyManager.setActiveItem(newFocusIndex);\n      let /** @type {?} */ focusChip = this._keyManager.activeItem;\n\n      // Focus the chip\n      if (focusChip) {\n        focusChip.focus();\n      }\n    }\n\n    // Reset our destroyed index\n    this._lastDestroyedIndex = null;\n  }\n/**\n * Utility to ensure all indexes are valid.\n * \n * @param {?} index The index to be checked.\n * @return {?} True if the index is valid for our list of chips.\n */\nprivate _isValidIndex(index: number): boolean {\n    return index >= 0 && index < this.chips.length;\n  }\n/**\n * @param {?} element\n * @return {?}\n */\nprivate _isInputEmpty(element: HTMLElement): boolean {\n    if (element && element.nodeName.toLowerCase() === 'input') {\n      let /** @type {?} */ input = /** @type {?} */(( element as HTMLInputElement));\n\n      return !input.value;\n    }\n\n    return false;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  moduleId: module.id,\n  selector: 'md-chip-list, mat-chip-list',\n  template: `<div class=\"mat-chip-list-wrapper\"><ng-content></ng-content></div>`,\n  exportAs: 'mdChipList',\n  host: {\n    '[attr.tabindex]': '_tabIndex',\n    'role': 'listbox',\n    'class': 'mat-chip-list',\n\n    '(focus)': 'focus()',\n    '(keydown)': '_keydown($event)'\n  },\n  queries: {\n    chips: new ContentChildren(MdChip)\n  },\n  styleUrls: ['chips.css'],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Renderer2, },\n{type: ElementRef, },\n{type: Directionality, decorators: [{ type: Optional }, ]},\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'selectable': [{ type: Input },],\n};\n}\n\nfunction MdChipList_tsickle_Closure_declarations() {\n/** @type {?} */\nMdChipList.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMdChipList.ctorParameters;\n/** @type {?} */\nMdChipList.propDecorators;\n/**\n * When a chip is destroyed, we track the index so we can focus the appropriate next chip.\n * @type {?}\n */\nMdChipList.prototype._lastDestroyedIndex;\n/**\n * Track which chips we're listening to for focus/destruction.\n * @type {?}\n */\nMdChipList.prototype._chipSet;\n/**\n * Subscription to tabbing out from the chip list.\n * @type {?}\n */\nMdChipList.prototype._tabOutSubscription;\n/**\n * Whether or not the chip is selectable.\n * @type {?}\n */\nMdChipList.prototype._selectable;\n/** @type {?} */\nMdChipList.prototype._inputElement;\n/**\n * Tab index for the chip list.\n * @type {?}\n */\nMdChipList.prototype._tabIndex;\n/**\n * The FocusKeyManager which handles focus.\n * @type {?}\n */\nMdChipList.prototype._keyManager;\n/**\n * The chip components contained within this chip list.\n * @type {?}\n */\nMdChipList.prototype.chips;\n/** @type {?} */\nMdChipList.prototype._renderer;\n/** @type {?} */\nMdChipList.prototype._elementRef;\n/** @type {?} */\nMdChipList.prototype._dir;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}