{"version":3,"sources":["../../../../src/lib/progress-spinner/progress-spinner.ts"],"names":[],"mappings":"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","file":"progress-spinner.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {\n  Component,\n  HostBinding,\n  ChangeDetectionStrategy,\n  OnDestroy,\n  Input,\n  ElementRef,\n  NgZone,\n  Renderer2,\n  Directive,\n  ViewChild,\n} from '@angular/core';\nimport {CanColor, mixinColor} from '../core/common-behaviors/color';\n/**\n * A single degree in radians.\n */\nconst DEGREE_IN_RADIANS = Math.PI / 180;\n/**\n * Duration of the indeterminate animation.\n */\nconst DURATION_INDETERMINATE = 667;\n/**\n * Duration of the indeterminate animation.\n */\nconst DURATION_DETERMINATE = 225;\n/**\n * Start animation value of the indeterminate animation\n */\nconst startIndeterminate = 3;\n/**\n * End animation value of the indeterminate animation\n */\nconst endIndeterminate = 80;\n/**\n * Maximum angle for the arc. The angle can't be exactly 360, because the arc becomes hidden.\n */\nconst MAX_ANGLE = 359.99 / 100;\n/**\n * Whether the user's browser supports requestAnimationFrame.\n */\nconst HAS_RAF = typeof requestAnimationFrame !== 'undefined';\n/**\n * Default stroke width as a percentage of the viewBox.\n */\nexport const PROGRESS_SPINNER_STROKE_WIDTH = 10;\n\nexport type ProgressSpinnerMode = 'determinate' | 'indeterminate';\n\ntype EasingFn = (currentTime: number, startValue: number,\n                 changeInValue: number, duration: number) => number;\n/**\n * Directive whose purpose is to add the mat- CSS styling to this selector.\n * \\@docs-private\n */\nexport class MdProgressSpinnerCssMatStyler {static decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: 'md-progress-spinner, mat-progress-spinner',\n  host: {'class': 'mat-progress-spinner'}\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction MdProgressSpinnerCssMatStyler_tsickle_Closure_declarations() {\n/** @type {?} */\nMdProgressSpinnerCssMatStyler.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMdProgressSpinnerCssMatStyler.ctorParameters;\n}\n\n/**\n * \\@docs-private\n */\nexport class MdProgressSpinnerBase {\n/**\n * @param {?} _renderer\n * @param {?} _elementRef\n */\nconstructor(public _renderer: Renderer2,\npublic _elementRef: ElementRef) {}\n}\n\nfunction MdProgressSpinnerBase_tsickle_Closure_declarations() {\n/** @type {?} */\nMdProgressSpinnerBase.prototype._renderer;\n/** @type {?} */\nMdProgressSpinnerBase.prototype._elementRef;\n}\n\nexport const /** @type {?} */ _MdProgressSpinnerMixinBase = mixinColor(MdProgressSpinnerBase, 'primary');\n/**\n * <md-progress-spinner> component.\n */\nexport class MdProgressSpinner extends _MdProgressSpinnerMixinBase\n    implements OnDestroy, CanColor {\n/**\n * The id of the last requested animation.\n */\nprivate _lastAnimationId: number = 0;\n/**\n * The id of the indeterminate interval.\n */\nprivate _interdeterminateInterval: number | null;\n/**\n * The SVG <path> node that is used to draw the circle.\n */\nprivate _path: ElementRef;\nprivate _mode: ProgressSpinnerMode = 'determinate';\nprivate _value: number;\n/**\n * Stroke width of the progress spinner. By default uses 10px as stroke width.\n */\nstrokeWidth: number = PROGRESS_SPINNER_STROKE_WIDTH;\n/**\n * Values for aria max and min are only defined as numbers when in a determinate mode.  We do this\n * because voiceover does not report the progress indicator as indeterminate if the aria min\n * and/or max value are number values.\n * @return {?}\n */\nget _ariaValueMin() {\n    return this.mode == 'determinate' ? 0 : null;\n  }\n/**\n * @return {?}\n */\nget _ariaValueMax() {\n    return this.mode == 'determinate' ? 100 : null;\n  }\n/**\n * \\@docs-private\n * @return {?}\n */\nget interdeterminateInterval() {\n    return this._interdeterminateInterval;\n  }\n/**\n * \\@docs-private\n * @param {?} interval\n * @return {?}\n */\nset interdeterminateInterval(interval: number | null) {\n    if (this._interdeterminateInterval) {\n      clearInterval(this._interdeterminateInterval);\n    }\n\n    this._interdeterminateInterval = interval;\n  }\n/**\n * Clean up any animations that were running.\n * @return {?}\n */\nngOnDestroy() {\n    this._cleanupIndeterminateAnimation();\n  }\n/**\n * Value of the progress circle. It is bound to the host as the attribute aria-valuenow.\n * @return {?}\n */\nget value() {\n    if (this.mode == 'determinate') {\n      return this._value;\n    }\n\n    return 0;\n  }\n/**\n * @param {?} v\n * @return {?}\n */\nset value(v: number) {\n    if (v != null && this.mode == 'determinate') {\n      let /** @type {?} */ newValue = clamp(v);\n      this._animateCircle(this.value || 0, newValue);\n      this._value = newValue;\n    }\n  }\n/**\n * Mode of the progress circle\n * \n * Input must be one of the values from ProgressMode, defaults to 'determinate'.\n * mode is bound to the host as the attribute host.\n * @return {?}\n */\nget mode() {\n    return this._mode;\n  }\n/**\n * @param {?} mode\n * @return {?}\n */\nset mode(mode: ProgressSpinnerMode) {\n    if (mode !== this._mode) {\n      if (mode === 'indeterminate') {\n        this._startIndeterminateAnimation();\n      } else {\n        this._cleanupIndeterminateAnimation();\n        this._animateCircle(0, this._value);\n      }\n      this._mode = mode;\n    }\n  }\n/**\n * @param {?} renderer\n * @param {?} elementRef\n * @param {?} _ngZone\n */\nconstructor(renderer: Renderer2,\n              elementRef: ElementRef,\nprivate _ngZone: NgZone) {\n    super(renderer, elementRef);\n  }\n/**\n * Animates the circle from one percentage value to another.\n * \n * @param {?} animateFrom The percentage of the circle filled starting the animation.\n * @param {?} animateTo The percentage of the circle filled ending the animation.\n * @param {?=} ease The easing function to manage the pace of change in the animation.\n * @param {?=} duration The length of time to show the animation, in milliseconds.\n * @param {?=} rotation The starting angle of the circle fill, with 0Â° represented at the top center\n *    of the circle.\n * @return {?}\n */\nprivate _animateCircle(animateFrom: number, animateTo: number, ease: EasingFn = linearEase,\n                        duration = DURATION_DETERMINATE, rotation = 0) {\n\n    let /** @type {?} */ id = ++this._lastAnimationId;\n    let /** @type {?} */ startTime = Date.now();\n    let /** @type {?} */ changeInValue = animateTo - animateFrom;\n\n    // No need to animate it if the values are the same\n    if (animateTo === animateFrom) {\n      this._renderArc(animateTo, rotation);\n    } else {\n      let /** @type {?} */ animation = () => {\n        // If there is no requestAnimationFrame, skip ahead to the end of the animation.\n        let /** @type {?} */ elapsedTime = HAS_RAF ?\n            Math.max(0, Math.min(Date.now() - startTime, duration)) :\n            duration;\n\n        this._renderArc(\n          ease(elapsedTime, animateFrom, changeInValue, duration),\n          rotation\n        );\n\n        // Prevent overlapping animations by checking if a new animation has been called for and\n        // if the animation has lasted longer than the animation duration.\n        if (id === this._lastAnimationId && elapsedTime < duration) {\n          requestAnimationFrame(animation);\n        }\n      };\n\n      // Run the animation outside of Angular's zone, in order to avoid\n      // hitting ZoneJS and change detection on each frame.\n      this._ngZone.runOutsideAngular(animation);\n    }\n  }\n/**\n * Starts the indeterminate animation interval, if it is not already running.\n * @return {?}\n */\nprivate _startIndeterminateAnimation() {\n    let /** @type {?} */ rotationStartPoint = 0;\n    let /** @type {?} */ start = startIndeterminate;\n    let /** @type {?} */ end = endIndeterminate;\n    let /** @type {?} */ duration = DURATION_INDETERMINATE;\n    let /** @type {?} */ animate = () => {\n      this._animateCircle(start, end, materialEase, duration, rotationStartPoint);\n      // Prevent rotation from reaching Number.MAX_SAFE_INTEGER.\n      rotationStartPoint = (rotationStartPoint + end) % 100;\n      let /** @type {?} */ temp = start;\n      start = -end;\n      end = -temp;\n    };\n\n    if (!this.interdeterminateInterval) {\n      this._ngZone.runOutsideAngular(() => {\n        this.interdeterminateInterval = setInterval(animate, duration + 50, 0, false);\n        animate();\n      });\n    }\n  }\n/**\n * Removes interval, ending the animation.\n * @return {?}\n */\nprivate _cleanupIndeterminateAnimation() {\n    this.interdeterminateInterval = null;\n  }\n/**\n * Renders the arc onto the SVG element. Proxies `getArc` while setting the proper\n * DOM attribute on the `<path>`.\n * @param {?} currentValue\n * @param {?=} rotation\n * @return {?}\n */\nprivate _renderArc(currentValue: number, rotation = 0) {\n    if (this._path) {\n      const /** @type {?} */ svgArc = getSvgArc(currentValue, rotation, this.strokeWidth);\n      this._renderer.setAttribute(this._path.nativeElement, 'd', svgArc);\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  moduleId: module.id,\n  selector: 'md-progress-spinner, mat-progress-spinner',\n  host: {\n    'role': 'progressbar',\n    '[attr.aria-valuemin]': '_ariaValueMin',\n    '[attr.aria-valuemax]': '_ariaValueMax'\n  },\n  inputs: ['color'],\n  templateUrl: 'progress-spinner.html',\n  styleUrls: ['progress-spinner.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Renderer2, },\n{type: ElementRef, },\n{type: NgZone, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'_path': [{ type: ViewChild, args: ['path', ] },],\n'strokeWidth': [{ type: Input },],\n'value': [{ type: Input },{ type: HostBinding, args: ['attr.aria-valuenow', ] },],\n'mode': [{ type: HostBinding, args: ['attr.mode', ] },{ type: Input },],\n};\n}\n\nfunction MdProgressSpinner_tsickle_Closure_declarations() {\n/** @type {?} */\nMdProgressSpinner.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMdProgressSpinner.ctorParameters;\n/** @type {?} */\nMdProgressSpinner.propDecorators;\n/**\n * The id of the last requested animation.\n * @type {?}\n */\nMdProgressSpinner.prototype._lastAnimationId;\n/**\n * The id of the indeterminate interval.\n * @type {?}\n */\nMdProgressSpinner.prototype._interdeterminateInterval;\n/**\n * The SVG <path> node that is used to draw the circle.\n * @type {?}\n */\nMdProgressSpinner.prototype._path;\n/** @type {?} */\nMdProgressSpinner.prototype._mode;\n/** @type {?} */\nMdProgressSpinner.prototype._value;\n/**\n * Stroke width of the progress spinner. By default uses 10px as stroke width.\n * @type {?}\n */\nMdProgressSpinner.prototype.strokeWidth;\n/** @type {?} */\nMdProgressSpinner.prototype._ngZone;\n}\n\n/**\n * <md-spinner> component.\n * \n * This is a component definition to be used as a convenience reference to create an\n * indeterminate <md-progress-spinner> instance.\n */\nexport class MdSpinner extends MdProgressSpinner {\n/**\n * @param {?} elementRef\n * @param {?} ngZone\n * @param {?} renderer\n */\nconstructor(elementRef: ElementRef, ngZone: NgZone, renderer: Renderer2) {\n    super(renderer, elementRef, ngZone);\n    this.mode = 'indeterminate';\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  moduleId: module.id,\n  selector: 'md-spinner, mat-spinner',\n  host: {\n    'role': 'progressbar',\n    'mode': 'indeterminate',\n    'class': 'mat-spinner',\n  },\n  inputs: ['color'],\n  templateUrl: 'progress-spinner.html',\n  styleUrls: ['progress-spinner.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: NgZone, },\n{type: Renderer2, },\n];\n}\n\nfunction MdSpinner_tsickle_Closure_declarations() {\n/** @type {?} */\nMdSpinner.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMdSpinner.ctorParameters;\n}\n\n/**\n * Clamps a value to be between 0 and 100.\n * @param {?} v\n * @return {?}\n */\nfunction clamp(v: number) {\n  return Math.max(0, Math.min(100, v));\n}\n/**\n * Converts Polar coordinates to Cartesian.\n * @param {?} radius\n * @param {?} pathRadius\n * @param {?} angleInDegrees\n * @return {?}\n */\nfunction polarToCartesian(radius: number, pathRadius: number, angleInDegrees: number) {\n  let /** @type {?} */ angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;\n\n  return (radius + (pathRadius * Math.cos(angleInRadians))) +\n    ',' + (radius + (pathRadius * Math.sin(angleInRadians)));\n}\n/**\n * Easing function for linear animation.\n * @param {?} currentTime\n * @param {?} startValue\n * @param {?} changeInValue\n * @param {?} duration\n * @return {?}\n */\nfunction linearEase(currentTime: number, startValue: number,\n                    changeInValue: number, duration: number) {\n  return changeInValue * currentTime / duration + startValue;\n}\n/**\n * Easing function to match material design indeterminate animation.\n * @param {?} currentTime\n * @param {?} startValue\n * @param {?} changeInValue\n * @param {?} duration\n * @return {?}\n */\nfunction materialEase(currentTime: number, startValue: number,\n                      changeInValue: number, duration: number) {\n  let /** @type {?} */ time = currentTime / duration;\n  let /** @type {?} */ timeCubed = Math.pow(time, 3);\n  let /** @type {?} */ timeQuad = Math.pow(time, 4);\n  let /** @type {?} */ timeQuint = Math.pow(time, 5);\n  return startValue + changeInValue * ((6 * timeQuint) + (-15 * timeQuad) + (10 * timeCubed));\n}\n/**\n * Determines the path value to define the arc.  Converting percentage values to to polar\n * coordinates on the circle, and then to cartesian coordinates in the viewport.\n * \n * @param {?} currentValue The current percentage value of the progress circle, the percentage of the\n *    circle to fill.\n * @param {?} rotation The starting point of the circle with 0 being the 0 degree point.\n * @param {?} strokeWidth Stroke width of the progress spinner arc.\n * @return {?} A string for an SVG path representing a circle filled from the starting point to the\n *    percentage value provided.\n */\nfunction getSvgArc(currentValue: number, rotation: number, strokeWidth: number): string {\n  let /** @type {?} */ startPoint = rotation || 0;\n  let /** @type {?} */ radius = 50;\n  let /** @type {?} */ pathRadius = radius - strokeWidth;\n\n  let /** @type {?} */ startAngle = startPoint * MAX_ANGLE;\n  let /** @type {?} */ endAngle = currentValue * MAX_ANGLE;\n  let /** @type {?} */ start = polarToCartesian(radius, pathRadius, startAngle);\n  let /** @type {?} */ end = polarToCartesian(radius, pathRadius, endAngle + startAngle);\n  let /** @type {?} */ arcSweep = endAngle < 0 ? 0 : 1;\n  let /** @type {?} */ largeArcFlag: number;\n\n  if (endAngle < 0) {\n    largeArcFlag = endAngle >= -180 ? 0 : 1;\n  } else {\n    largeArcFlag = endAngle <= 180 ? 0 : 1;\n  }\n\n  return `M${start}A${pathRadius},${pathRadius} 0 ${largeArcFlag},${arcSweep} ${end}`;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}