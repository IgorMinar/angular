/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, Directive, ElementRef, Inject, Input, Optional, Renderer2, Self, ViewChild, ViewEncapsulation, } from '@angular/core';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { coerceBooleanProperty, Platform } from '../core';
import { FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { getSupportedInputTypes } from '../core/platform/features';
import { getMdInputContainerDuplicatedHintError, getMdInputContainerMissingMdInputError, getMdInputContainerPlaceholderConflictError, getMdInputContainerUnsupportedTypeError } from './input-container-errors';
import { MD_PLACEHOLDER_GLOBAL_OPTIONS } from '../core/placeholder/placeholder-options';
import { defaultErrorStateMatcher, MD_ERROR_GLOBAL_OPTIONS } from '../core/error/error-options';
import { Subject } from 'rxjs/Subject';
// Invalid input type. Using one of these will throw an MdInputContainerUnsupportedTypeError.
var /** @type {?} */ MD_INPUT_INVALID_TYPES = [
    'button',
    'checkbox',
    'color',
    'file',
    'hidden',
    'image',
    'radio',
    'range',
    'reset',
    'submit'
];
var /** @type {?} */ nextUniqueId = 0;
/**
 * The placeholder directive. The content can declare this to implement more
 * complex placeholders.
 */
var MdPlaceholder = (function () {
    function MdPlaceholder() {
    }
    return MdPlaceholder;
}());
export { MdPlaceholder };
MdPlaceholder.decorators = [
    { type: Directive, args: [{
                selector: 'md-placeholder, mat-placeholder'
            },] },
];
/**
 * @nocollapse
 */
MdPlaceholder.ctorParameters = function () { return []; };
function MdPlaceholder_tsickle_Closure_declarations() {
    /** @type {?} */
    MdPlaceholder.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    MdPlaceholder.ctorParameters;
}
/**
 * Hint text to be shown underneath the input.
 */
var MdHint = (function () {
    function MdHint() {
        /**
         * Whether to align the hint label at the start or end of the line.
         */
        this.align = 'start';
        /**
         * Unique ID for the hint. Used for the aria-describedby on the input.
         */
        this.id = "md-input-hint-" + nextUniqueId++;
    }
    return MdHint;
}());
export { MdHint };
MdHint.decorators = [
    { type: Directive, args: [{
                selector: 'md-hint, mat-hint',
                host: {
                    'class': 'mat-hint',
                    '[class.mat-right]': 'align == "end"',
                    '[attr.id]': 'id',
                }
            },] },
];
/**
 * @nocollapse
 */
MdHint.ctorParameters = function () { return []; };
MdHint.propDecorators = {
    'align': [{ type: Input },],
    'id': [{ type: Input },],
};
function MdHint_tsickle_Closure_declarations() {
    /** @type {?} */
    MdHint.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    MdHint.ctorParameters;
    /** @type {?} */
    MdHint.propDecorators;
    /**
     * Whether to align the hint label at the start or end of the line.
     * @type {?}
     */
    MdHint.prototype.align;
    /**
     * Unique ID for the hint. Used for the aria-describedby on the input.
     * @type {?}
     */
    MdHint.prototype.id;
}
/**
 * Single error message to be shown underneath the input.
 */
var MdErrorDirective = (function () {
    function MdErrorDirective() {
    }
    return MdErrorDirective;
}());
export { MdErrorDirective };
MdErrorDirective.decorators = [
    { type: Directive, args: [{
                selector: 'md-error, mat-error',
                host: {
                    'class': 'mat-input-error'
                }
            },] },
];
/**
 * @nocollapse
 */
MdErrorDirective.ctorParameters = function () { return []; };
function MdErrorDirective_tsickle_Closure_declarations() {
    /** @type {?} */
    MdErrorDirective.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    MdErrorDirective.ctorParameters;
}
/**
 * Prefix to be placed the the front of the input.
 */
var MdPrefix = (function () {
    function MdPrefix() {
    }
    return MdPrefix;
}());
export { MdPrefix };
MdPrefix.decorators = [
    { type: Directive, args: [{
                selector: '[mdPrefix], [matPrefix]'
            },] },
];
/**
 * @nocollapse
 */
MdPrefix.ctorParameters = function () { return []; };
function MdPrefix_tsickle_Closure_declarations() {
    /** @type {?} */
    MdPrefix.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    MdPrefix.ctorParameters;
}
/**
 * Suffix to be placed at the end of the input.
 */
var MdSuffix = (function () {
    function MdSuffix() {
    }
    return MdSuffix;
}());
export { MdSuffix };
MdSuffix.decorators = [
    { type: Directive, args: [{
                selector: '[mdSuffix], [matSuffix]'
            },] },
];
/**
 * @nocollapse
 */
MdSuffix.ctorParameters = function () { return []; };
function MdSuffix_tsickle_Closure_declarations() {
    /** @type {?} */
    MdSuffix.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    MdSuffix.ctorParameters;
}
/**
 * Marker for the input element that `MdInputContainer` is wrapping.
 */
var MdInputDirective = (function () {
    /**
     * @param {?} _elementRef
     * @param {?} _renderer
     * @param {?} _platform
     * @param {?} _ngControl
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     * @param {?} errorOptions
     */
    function MdInputDirective(_elementRef, _renderer, _platform, _ngControl, _parentForm, _parentFormGroup, errorOptions) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._platform = _platform;
        this._ngControl = _ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        /**
         * Variables used as cache for getters and setters.
         */
        this._type = 'text';
        this._placeholder = '';
        this._disabled = false;
        this._required = false;
        this._readonly = false;
        this._uid = "md-input-" + nextUniqueId++;
        this._previousNativeValue = this.value;
        /**
         * Whether the input is in an error state.
         */
        this._isErrorState = false;
        /**
         * Whether the element is focused or not.
         */
        this.focused = false;
        /**
         * Stream that emits whenever the state of the input changes. This allows for other components
         * (mostly `md-input-container`) that depend on the properties of `mdInput` to update their view.
         */
        this._stateChanges = new Subject();
        /**
         * Placeholder attribute of the element.
         */
        this.placeholder = '';
        this._neverEmptyInputTypes = [
            'date',
            'datetime',
            'datetime-local',
            'month',
            'time',
            'week'
        ].filter(function (t) { return getSupportedInputTypes().has(t); });
        // Force setter to be called in case id was not specified.
        this.id = this.id;
        this._errorOptions = errorOptions ? errorOptions : {};
        this.errorStateMatcher = this._errorOptions.errorStateMatcher || defaultErrorStateMatcher;
        // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete
        // key. In order to get around this we need to "jiggle" the caret loose. Since this bug only
        // exists on iOS, we only bother to install the listener on iOS.
        if (_platform.IOS) {
            _renderer.listen(_elementRef.nativeElement, 'keyup', function (event) {
                var el = event.target;
                if (!el.value && !el.selectionStart && !el.selectionEnd) {
                    // Note: Just setting `0, 0` doesn't fix the issue. Setting `1, 1` fixes it for the first
                    // time that you type text and then hold delete. Toggling to `1, 1` and then back to
                    // `0, 0` seems to completely fix it.
                    el.setSelectionRange(1, 1);
                    el.setSelectionRange(0, 0);
                }
            });
        }
    }
    Object.defineProperty(MdInputDirective.prototype, "disabled", {
        /**
         * Whether the element is disabled.
         * @return {?}
         */
        get: function () { return this._ngControl ? this._ngControl.disabled : this._disabled; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) { this._disabled = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdInputDirective.prototype, "id", {
        /**
         * Unique id of the element.
         * @return {?}
         */
        get: function () { return this._id; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) { this._id = value || this._uid; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdInputDirective.prototype, "required", {
        /**
         * Whether the element is required.
         * @return {?}
         */
        get: function () { return this._required; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) { this._required = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdInputDirective.prototype, "type", {
        /**
         * Input type of the element.
         * @return {?}
         */
        get: function () { return this._type; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this._type = value || 'text';
            this._validateType();
            // When using Angular inputs, developers are no longer able to set the properties on the native
            // input element. To ensure that bindings for `type` work, we need to sync the setter
            // with the native property. Textarea elements don't support the type property or attribute.
            if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {
                this._renderer.setProperty(this._elementRef.nativeElement, 'type', this._type);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdInputDirective.prototype, "readonly", {
        /**
         * Whether the element is readonly.
         * @return {?}
         */
        get: function () { return this._readonly; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) { this._readonly = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdInputDirective.prototype, "value", {
        /**
         * The input element's value.
         * @return {?}
         */
        get: function () { return this._elementRef.nativeElement.value; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            if (value !== this.value) {
                this._elementRef.nativeElement.value = value;
                this._stateChanges.next();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdInputDirective.prototype, "empty", {
        /**
         * Whether the input is empty.
         * @return {?}
         */
        get: function () {
            return !this._isNeverEmpty() &&
                (this.value == null || this.value === '') &&
                // Check if the input contains bad input. If so, we know that it only appears empty because
                // the value failed to parse. From the user's perspective it is not empty.
                // TODO(mmalerba): Add e2e test for bad input case.
                !this._isBadInput();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MdInputDirective.prototype.ngOnChanges = function () {
        this._stateChanges.next();
    };
    /**
     * @return {?}
     */
    MdInputDirective.prototype.ngOnDestroy = function () {
        this._stateChanges.complete();
    };
    /**
     * @return {?}
     */
    MdInputDirective.prototype.ngDoCheck = function () {
        if (this._ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this._updateErrorState();
        }
        else {
            // When the input isn't used together with `@angular/forms`, we need to check manually for
            // changes to the native `value` property in order to update the floating label.
            this._dirtyCheckNativeValue();
        }
    };
    /**
     * @return {?}
     */
    MdInputDirective.prototype._onFocus = function () {
        if (!this._readonly) {
            this.focused = true;
        }
    };
    /**
     * Focuses the input element.
     * @return {?}
     */
    MdInputDirective.prototype.focus = function () {
        this._elementRef.nativeElement.focus();
    };
    /**
     * Callback for the cases where the focused state of the input changes.
     * @param {?} isFocused
     * @return {?}
     */
    MdInputDirective.prototype._focusChanged = function (isFocused) {
        if (isFocused !== this.focused) {
            this.focused = isFocused;
            this._stateChanges.next();
        }
    };
    /**
     * @return {?}
     */
    MdInputDirective.prototype._onInput = function () {
        // This is a noop function and is used to let Angular know whenever the value changes.
        // Angular will run a new change detection each time the `input` event has been dispatched.
        // It's necessary that Angular recognizes the value change, because when floatingLabel
        // is set to false and Angular forms aren't used, the placeholder won't recognize the
        // value changes and will not disappear.
        // Listening to the input event wouldn't be necessary when the input is using the
        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.
    };
    /**
     * Re-evaluates the error state. This is only relevant with \@angular/forms.
     * @return {?}
     */
    MdInputDirective.prototype._updateErrorState = function () {
        var /** @type {?} */ oldState = this._isErrorState;
        var /** @type {?} */ control = this._ngControl;
        var /** @type {?} */ parent = this._parentFormGroup || this._parentForm;
        var /** @type {?} */ newState = control && this.errorStateMatcher(/** @type {?} */ (control.control), parent);
        if (newState !== oldState) {
            this._isErrorState = newState;
            this._stateChanges.next();
        }
    };
    /**
     * Does some manual dirty checking on the native input `value` property.
     * @return {?}
     */
    MdInputDirective.prototype._dirtyCheckNativeValue = function () {
        var /** @type {?} */ newValue = this.value;
        if (this._previousNativeValue !== newValue) {
            this._previousNativeValue = newValue;
            this._stateChanges.next();
        }
    };
    /**
     * Make sure the input is a supported type.
     * @return {?}
     */
    MdInputDirective.prototype._validateType = function () {
        if (MD_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {
            throw getMdInputContainerUnsupportedTypeError(this._type);
        }
    };
    /**
     * Checks whether the input type isn't one of the types that are never empty.
     * @return {?}
     */
    MdInputDirective.prototype._isNeverEmpty = function () {
        return this._neverEmptyInputTypes.indexOf(this._type) > -1;
    };
    /**
     * Checks whether the input is invalid based on the native validation.
     * @return {?}
     */
    MdInputDirective.prototype._isBadInput = function () {
        // The `validity` property won't be present on platform-server.
        var /** @type {?} */ validity = ((this._elementRef.nativeElement)).validity;
        return validity && validity.badInput;
    };
    /**
     * Determines if the component host is a textarea. If not recognizable it returns false.
     * @return {?}
     */
    MdInputDirective.prototype._isTextarea = function () {
        var /** @type {?} */ nativeElement = this._elementRef.nativeElement;
        // In Universal, we don't have access to `nodeName`, but the same can be achieved with `name`.
        // Note that this shouldn't be necessary once Angular switches to an API that resembles the
        // DOM closer.
        var /** @type {?} */ nodeName = this._platform.isBrowser ? nativeElement.nodeName : nativeElement.name;
        return nodeName ? nodeName.toLowerCase() === 'textarea' : false;
    };
    return MdInputDirective;
}());
export { MdInputDirective };
MdInputDirective.decorators = [
    { type: Directive, args: [{
                selector: "input[mdInput], textarea[mdInput], input[matInput], textarea[matInput]",
                host: {
                    'class': 'mat-input-element',
                    // Native input properties that are overwritten by Angular inputs need to be synced with
                    // the native input element. Otherwise property bindings for those don't work.
                    '[id]': 'id',
                    '[placeholder]': 'placeholder',
                    '[disabled]': 'disabled',
                    '[required]': 'required',
                    '[attr.aria-describedby]': 'ariaDescribedby || null',
                    '[attr.aria-invalid]': '_isErrorState',
                    '(blur)': '_focusChanged(false)',
                    '(focus)': '_focusChanged(true)',
                    '(input)': '_onInput()',
                }
            },] },
];
/**
 * @nocollapse
 */
MdInputDirective.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: Platform, },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self },] },
    { type: NgForm, decorators: [{ type: Optional },] },
    { type: FormGroupDirective, decorators: [{ type: Optional },] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MD_ERROR_GLOBAL_OPTIONS,] },] },
]; };
MdInputDirective.propDecorators = {
    'disabled': [{ type: Input },],
    'id': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'required': [{ type: Input },],
    'type': [{ type: Input },],
    'readonly': [{ type: Input },],
    'errorStateMatcher': [{ type: Input },],
};
function MdInputDirective_tsickle_Closure_declarations() {
    /** @type {?} */
    MdInputDirective.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    MdInputDirective.ctorParameters;
    /** @type {?} */
    MdInputDirective.propDecorators;
    /**
     * Variables used as cache for getters and setters.
     * @type {?}
     */
    MdInputDirective.prototype._type;
    /** @type {?} */
    MdInputDirective.prototype._placeholder;
    /** @type {?} */
    MdInputDirective.prototype._disabled;
    /** @type {?} */
    MdInputDirective.prototype._required;
    /** @type {?} */
    MdInputDirective.prototype._readonly;
    /** @type {?} */
    MdInputDirective.prototype._id;
    /** @type {?} */
    MdInputDirective.prototype._uid;
    /** @type {?} */
    MdInputDirective.prototype._errorOptions;
    /** @type {?} */
    MdInputDirective.prototype._previousNativeValue;
    /**
     * Whether the input is in an error state.
     * @type {?}
     */
    MdInputDirective.prototype._isErrorState;
    /**
     * Whether the element is focused or not.
     * @type {?}
     */
    MdInputDirective.prototype.focused;
    /**
     * Sets the aria-describedby attribute on the input for improved a11y.
     * @type {?}
     */
    MdInputDirective.prototype.ariaDescribedby;
    /**
     * Stream that emits whenever the state of the input changes. This allows for other components
     * (mostly `md-input-container`) that depend on the properties of `mdInput` to update their view.
     * @type {?}
     */
    MdInputDirective.prototype._stateChanges;
    /**
     * Placeholder attribute of the element.
     * @type {?}
     */
    MdInputDirective.prototype.placeholder;
    /**
     * A function used to control when error messages are shown.
     * @type {?}
     */
    MdInputDirective.prototype.errorStateMatcher;
    /** @type {?} */
    MdInputDirective.prototype._neverEmptyInputTypes;
    /** @type {?} */
    MdInputDirective.prototype._elementRef;
    /** @type {?} */
    MdInputDirective.prototype._renderer;
    /** @type {?} */
    MdInputDirective.prototype._platform;
    /** @type {?} */
    MdInputDirective.prototype._ngControl;
    /** @type {?} */
    MdInputDirective.prototype._parentForm;
    /** @type {?} */
    MdInputDirective.prototype._parentFormGroup;
}
/**
 * Container for text inputs that applies Material Design styling and behavior.
 */
var MdInputContainer = (function () {
    /**
     * @param {?} _elementRef
     * @param {?} _changeDetectorRef
     * @param {?} placeholderOptions
     */
    function MdInputContainer(_elementRef, _changeDetectorRef, placeholderOptions) {
        this._elementRef = _elementRef;
        this._changeDetectorRef = _changeDetectorRef;
        /**
         * Color of the input divider, based on the theme.
         */
        this.color = 'primary';
        /**
         * State of the md-hint and md-error animations.
         */
        this._subscriptAnimationState = '';
        this._hintLabel = '';
        // Unique id for the hint label.
        this._hintLabelId = "md-input-hint-" + nextUniqueId++;
        this._placeholderOptions = placeholderOptions ? placeholderOptions : {};
        this.floatPlaceholder = this._placeholderOptions.float || 'auto';
    }
    Object.defineProperty(MdInputContainer.prototype, "dividerColor", {
        /**
         * @deprecated Use `color` instead.
         * @return {?}
         */
        get: function () { return this.color; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) { this.color = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdInputContainer.prototype, "hideRequiredMarker", {
        /**
         * Whether the required marker should be hidden.
         * @return {?}
         */
        get: function () { return this._hideRequiredMarker; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this._hideRequiredMarker = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdInputContainer.prototype, "_shouldAlwaysFloat", {
        /**
         * Whether the floating label should always float or not.
         * @return {?}
         */
        get: function () { return this._floatPlaceholder === 'always'; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdInputContainer.prototype, "_canPlaceholderFloat", {
        /**
         * Whether the placeholder can float or not.
         * @return {?}
         */
        get: function () { return this._floatPlaceholder !== 'never'; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdInputContainer.prototype, "hintLabel", {
        /**
         * Text for the input hint.
         * @return {?}
         */
        get: function () { return this._hintLabel; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            this._hintLabel = value;
            this._processHints();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdInputContainer.prototype, "floatPlaceholder", {
        /**
         * Whether the placeholder should always float, never float or float as the user types.
         * @return {?}
         */
        get: function () { return this._floatPlaceholder; },
        /**
         * @param {?} value
         * @return {?}
         */
        set: function (value) {
            if (value !== this._floatPlaceholder) {
                this._floatPlaceholder = value || this._placeholderOptions.float || 'auto';
                this._changeDetectorRef.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MdInputContainer.prototype.ngAfterContentInit = function () {
        var _this = this;
        this._validateInputChild();
        this._processHints();
        this._validatePlaceholders();
        // Subscribe to changes in the child input state in order to update the container UI.
        this._mdInputChild._stateChanges.subscribe(function () {
            _this._validatePlaceholders();
            _this._changeDetectorRef.markForCheck();
        });
        if (this._mdInputChild._ngControl && this._mdInputChild._ngControl.valueChanges) {
            this._mdInputChild._ngControl.valueChanges.subscribe(function () {
                _this._changeDetectorRef.markForCheck();
            });
        }
        // Re-validate when the amount of hints changes.
        this._hintChildren.changes.subscribe(function () { return _this._processHints(); });
    };
    /**
     * @return {?}
     */
    MdInputContainer.prototype.ngAfterContentChecked = function () {
        this._validateInputChild();
    };
    /**
     * @return {?}
     */
    MdInputContainer.prototype.ngAfterViewInit = function () {
        // Avoid animations on load.
        this._subscriptAnimationState = 'enter';
        this._changeDetectorRef.detectChanges();
    };
    /**
     * Determines whether a class from the NgControl should be forwarded to the host element.
     * @param {?} prop
     * @return {?}
     */
    MdInputContainer.prototype._shouldForward = function (prop) {
        var /** @type {?} */ control = this._mdInputChild ? this._mdInputChild._ngControl : null;
        return control && ((control))[prop];
    };
    /**
     * Whether the input has a placeholder.
     * @return {?}
     */
    MdInputContainer.prototype._hasPlaceholder = function () {
        return !!(this._mdInputChild.placeholder || this._placeholderChild);
    };
    /**
     * Focuses the underlying input.
     * @return {?}
     */
    MdInputContainer.prototype._focusInput = function () {
        this._mdInputChild.focus();
    };
    /**
     * Determines whether to display hints or errors.
     * @return {?}
     */
    MdInputContainer.prototype._getDisplayedMessages = function () {
        var /** @type {?} */ input = this._mdInputChild;
        return (this._errorChildren.length > 0 && input._isErrorState) ? 'error' : 'hint';
    };
    /**
     * Ensure that there is only one placeholder (either `input` attribute or child element with the
     * `md-placeholder` attribute.
     * @return {?}
     */
    MdInputContainer.prototype._validatePlaceholders = function () {
        if (this._mdInputChild.placeholder && this._placeholderChild) {
            throw getMdInputContainerPlaceholderConflictError();
        }
    };
    /**
     * Does any extra processing that is required when handling the hints.
     * @return {?}
     */
    MdInputContainer.prototype._processHints = function () {
        this._validateHints();
        this._syncAriaDescribedby();
    };
    /**
     * Ensure that there is a maximum of one of each `<md-hint>` alignment specified, with the
     * attribute being considered as `align="start"`.
     * @return {?}
     */
    MdInputContainer.prototype._validateHints = function () {
        var _this = this;
        if (this._hintChildren) {
            var /** @type {?} */ startHint_1;
            var /** @type {?} */ endHint_1;
            this._hintChildren.forEach(function (hint) {
                if (hint.align == 'start') {
                    if (startHint_1 || _this.hintLabel) {
                        throw getMdInputContainerDuplicatedHintError('start');
                    }
                    startHint_1 = hint;
                }
                else if (hint.align == 'end') {
                    if (endHint_1) {
                        throw getMdInputContainerDuplicatedHintError('end');
                    }
                    endHint_1 = hint;
                }
            });
        }
    };
    /**
     * Sets the child input's `aria-describedby` to a space-separated list of the ids
     * of the currently-specified hints, as well as a generated id for the hint label.
     * @return {?}
     */
    MdInputContainer.prototype._syncAriaDescribedby = function () {
        if (this._mdInputChild) {
            var /** @type {?} */ ids = [];
            var /** @type {?} */ startHint = this._hintChildren ?
                this._hintChildren.find(function (hint) { return hint.align === 'start'; }) : null;
            var /** @type {?} */ endHint = this._hintChildren ?
                this._hintChildren.find(function (hint) { return hint.align === 'end'; }) : null;
            if (startHint) {
                ids.push(startHint.id);
            }
            else if (this._hintLabel) {
                ids.push(this._hintLabelId);
            }
            if (endHint) {
                ids.push(endHint.id);
            }
            this._mdInputChild.ariaDescribedby = ids.join(' ');
        }
    };
    /**
     * Throws an error if the container's input child was removed.
     * @return {?}
     */
    MdInputContainer.prototype._validateInputChild = function () {
        if (!this._mdInputChild) {
            throw getMdInputContainerMissingMdInputError();
        }
    };
    return MdInputContainer;
}());
export { MdInputContainer };
MdInputContainer.decorators = [
    { type: Component, args: [{selector: 'md-input-container, mat-input-container',
                template: "<div class=\"mat-input-wrapper\"><div class=\"mat-input-flex\"><div class=\"mat-input-prefix\" *ngIf=\"_prefixChildren.length\"><ng-content select=\"[mdPrefix], [matPrefix]\"></ng-content></div><div class=\"mat-input-infix\"><ng-content selector=\"input, textarea\"></ng-content><span class=\"mat-input-placeholder-wrapper\"><label class=\"mat-input-placeholder\" [attr.for]=\"_mdInputChild.id\" [class.mat-empty]=\"_mdInputChild.empty && !_shouldAlwaysFloat\" [class.mat-float]=\"_canPlaceholderFloat\" [class.mat-accent]=\"color == 'accent'\" [class.mat-warn]=\"color == 'warn'\" *ngIf=\"_hasPlaceholder()\"><ng-content select=\"md-placeholder, mat-placeholder\"></ng-content>{{_mdInputChild.placeholder}} <span class=\"mat-placeholder-required\" *ngIf=\"!hideRequiredMarker && _mdInputChild.required\">*</span></label></span></div><div class=\"mat-input-suffix\" *ngIf=\"_suffixChildren.length\"><ng-content select=\"[mdSuffix], [matSuffix]\"></ng-content></div></div><div class=\"mat-input-underline\" #underline [class.mat-disabled]=\"_mdInputChild.disabled\"><span class=\"mat-input-ripple\" [class.mat-accent]=\"color == 'accent'\" [class.mat-warn]=\"color == 'warn'\"></span></div><div class=\"mat-input-subscript-wrapper\" [ngSwitch]=\"_getDisplayedMessages()\"><div *ngSwitchCase=\"'error'\" [@transitionMessages]=\"_subscriptAnimationState\"><ng-content select=\"md-error, mat-error\"></ng-content></div><div class=\"mat-input-hint-wrapper\" *ngSwitchCase=\"'hint'\" [@transitionMessages]=\"_subscriptAnimationState\"><div *ngIf=\"hintLabel\" [id]=\"_hintLabelId\" class=\"mat-hint\">{{hintLabel}}</div><ng-content select=\"md-hint:not([align='end']), mat-hint:not([align='end'])\"></ng-content><div class=\"mat-input-hint-spacer\"></div><ng-content select=\"md-hint[align='end'], mat-hint[align='end']\"></ng-content></div></div></div>",
                styles: [".mat-input-container{display:inline-block;position:relative;width:200px;text-align:left}[dir=rtl] .mat-input-container{text-align:right}.mat-input-wrapper{position:relative}.mat-input-flex{display:inline-flex;align-items:baseline;width:100%}.mat-input-prefix,.mat-input-suffix{white-space:nowrap;flex:none}.mat-input-prefix .mat-icon,.mat-input-suffix .mat-icon{width:1em}.mat-input-prefix .mat-icon-button,.mat-input-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-input-prefix .mat-icon-button .mat-icon,.mat-input-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-input-infix{display:block;position:relative;flex:auto}.mat-input-element{font:inherit;background:0 0;color:currentColor;border:none;outline:0;padding:0;margin:0;width:100%;max-width:100%;resize:vertical;vertical-align:bottom}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element:-webkit-autofill+.mat-input-placeholder-wrapper .mat-input-placeholder{display:none}.mat-input-element:-webkit-autofill+.mat-input-placeholder-wrapper .mat-float{display:block;transition:none}.mat-input-element::placeholder{color:transparent!important}.mat-input-element::-moz-placeholder{color:transparent!important}.mat-input-element::-webkit-input-placeholder{color:transparent!important}.mat-input-element:-ms-input-placeholder{color:transparent!important}.mat-input-placeholder-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}textarea.mat-input-element{overflow:auto}.mat-input-placeholder{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform:perspective(100px);-ms-transform:none;transform-origin:0 0;transition:transform .4s cubic-bezier(.25,.8,.25,1),color .4s cubic-bezier(.25,.8,.25,1),width .4s cubic-bezier(.25,.8,.25,1);display:none}.mat-focused .mat-input-placeholder.mat-float,.mat-input-placeholder.mat-empty,.mat-input-placeholder.mat-float:not(.mat-empty){display:block}[dir=rtl] .mat-input-placeholder{transform-origin:100% 0;left:auto;right:0}.mat-input-placeholder:not(.mat-empty){transition:none}.mat-input-underline{position:absolute;height:1px;width:100%}.mat-input-underline.mat-disabled{background-position:0;background-color:transparent}.mat-input-underline .mat-input-ripple{position:absolute;height:1px;top:0;left:0;width:100%;transform-origin:50%;transform:scaleX(.5);visibility:hidden;transition:background-color .3s cubic-bezier(.55,0,.55,.2)}.mat-focused .mat-input-underline .mat-input-ripple{height:2px}.mat-focused .mat-input-underline .mat-input-ripple,.mat-input-invalid .mat-input-underline .mat-input-ripple{visibility:visible;transform:scaleX(1);transition:transform 150ms linear,background-color .3s cubic-bezier(.55,0,.55,.2)}.mat-input-subscript-wrapper{position:absolute;width:100%;overflow:hidden}.mat-input-placeholder-wrapper .mat-icon,.mat-input-subscript-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-input-hint-wrapper{display:flex}.mat-input-hint-spacer{flex:1 0 1em}.mat-input-error{display:block}"],
                animations: [
                    trigger('transitionMessages', [
                        state('enter', style({ opacity: 1, transform: 'translateY(0%)' })),
                        transition('void => enter', [
                            style({ opacity: 0, transform: 'translateY(-100%)' }),
                            animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')
                        ])
                    ])
                ],
                host: {
                    // Remove align attribute to prevent it from interfering with layout.
                    '[attr.align]': 'null',
                    'class': 'mat-input-container',
                    '[class.mat-input-invalid]': '_mdInputChild._isErrorState',
                    '[class.mat-focused]': '_mdInputChild.focused',
                    '[class.ng-untouched]': '_shouldForward("untouched")',
                    '[class.ng-touched]': '_shouldForward("touched")',
                    '[class.ng-pristine]': '_shouldForward("pristine")',
                    '[class.ng-dirty]': '_shouldForward("dirty")',
                    '[class.ng-valid]': '_shouldForward("valid")',
                    '[class.ng-invalid]': '_shouldForward("invalid")',
                    '[class.ng-pending]': '_shouldForward("pending")',
                    '(click)': '_focusInput()',
                },
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/**
 * @nocollapse
 */
MdInputContainer.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MD_PLACEHOLDER_GLOBAL_OPTIONS,] },] },
]; };
MdInputContainer.propDecorators = {
    'color': [{ type: Input },],
    'dividerColor': [{ type: Input },],
    'hideRequiredMarker': [{ type: Input },],
    'hintLabel': [{ type: Input },],
    'floatPlaceholder': [{ type: Input },],
    'underlineRef': [{ type: ViewChild, args: ['underline',] },],
    '_mdInputChild': [{ type: ContentChild, args: [MdInputDirective,] },],
    '_placeholderChild': [{ type: ContentChild, args: [MdPlaceholder,] },],
    '_errorChildren': [{ type: ContentChildren, args: [MdErrorDirective,] },],
    '_hintChildren': [{ type: ContentChildren, args: [MdHint,] },],
    '_prefixChildren': [{ type: ContentChildren, args: [MdPrefix,] },],
    '_suffixChildren': [{ type: ContentChildren, args: [MdSuffix,] },],
};
function MdInputContainer_tsickle_Closure_declarations() {
    /** @type {?} */
    MdInputContainer.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    MdInputContainer.ctorParameters;
    /** @type {?} */
    MdInputContainer.propDecorators;
    /** @type {?} */
    MdInputContainer.prototype._placeholderOptions;
    /**
     * Color of the input divider, based on the theme.
     * @type {?}
     */
    MdInputContainer.prototype.color;
    /** @type {?} */
    MdInputContainer.prototype._hideRequiredMarker;
    /**
     * State of the md-hint and md-error animations.
     * @type {?}
     */
    MdInputContainer.prototype._subscriptAnimationState;
    /** @type {?} */
    MdInputContainer.prototype._hintLabel;
    /** @type {?} */
    MdInputContainer.prototype._hintLabelId;
    /** @type {?} */
    MdInputContainer.prototype._floatPlaceholder;
    /**
     * Reference to the input's underline element.
     * @type {?}
     */
    MdInputContainer.prototype.underlineRef;
    /** @type {?} */
    MdInputContainer.prototype._mdInputChild;
    /** @type {?} */
    MdInputContainer.prototype._placeholderChild;
    /** @type {?} */
    MdInputContainer.prototype._errorChildren;
    /** @type {?} */
    MdInputContainer.prototype._hintChildren;
    /** @type {?} */
    MdInputContainer.prototype._prefixChildren;
    /** @type {?} */
    MdInputContainer.prototype._suffixChildren;
    /** @type {?} */
    MdInputContainer.prototype._elementRef;
    /** @type {?} */
    MdInputContainer.prototype._changeDetectorRef;
}
//# sourceMappingURL=input-container.js.map