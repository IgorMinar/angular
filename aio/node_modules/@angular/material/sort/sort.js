/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directive, EventEmitter, Input, Output } from '@angular/core';
import { coerceBooleanProperty } from '../core';
import { getMdSortDuplicateMdSortableIdError, getMdSortHeaderMissingIdError } from './sort-errors';
/**
 * Container for MdSortables to manage the sort state and provide default sort parameters.
 */
var MdSort = (function () {
    function MdSort() {
        /**
         * Collection of all registered sortables that this directive manages.
         */
        this.sortables = new Map();
        /**
         * The direction to set when an MdSortable is initially sorted.
         * May be overriden by the MdSortable's sort start.
         */
        this.start = 'asc';
        /**
         * The sort direction of the currently active MdSortable.
         */
        this.direction = '';
        /**
         * Event emitted when the user changes either the active sort or sort direction.
         */
        this.mdSortChange = new EventEmitter();
    }
    Object.defineProperty(MdSort.prototype, "disableClear", {
        /**
         * Whether to disable the user from clearing the sort by finishing the sort direction cycle.
         * May be overriden by the MdSortable's disable clear input.
         * @return {?}
         */
        get: function () { return this._disableClear; },
        /**
         * @param {?} v
         * @return {?}
         */
        set: function (v) { this._disableClear = coerceBooleanProperty(v); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSort.prototype, "_matSortActive", {
        /**
         * @return {?}
         */
        get: function () { return this.active; },
        /**
         * @param {?} v
         * @return {?}
         */
        set: function (v) { this.active = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSort.prototype, "_matSortStart", {
        /**
         * @return {?}
         */
        get: function () { return this.start; },
        /**
         * @param {?} v
         * @return {?}
         */
        set: function (v) { this.start = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSort.prototype, "_matSortDirection", {
        /**
         * @return {?}
         */
        get: function () { return this.direction; },
        /**
         * @param {?} v
         * @return {?}
         */
        set: function (v) { this.direction = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdSort.prototype, "_matSortDisableClear", {
        /**
         * @return {?}
         */
        get: function () { return this.disableClear; },
        /**
         * @param {?} v
         * @return {?}
         */
        set: function (v) { this.disableClear = v; },
        enumerable: true,
        configurable: true
    });
    /**
     * Register function to be used by the contained MdSortables. Adds the MdSortable to the
     * collection of MdSortables.
     * @param {?} sortable
     * @return {?}
     */
    MdSort.prototype.register = function (sortable) {
        if (!sortable.id) {
            throw getMdSortHeaderMissingIdError();
        }
        if (this.sortables.has(sortable.id)) {
            throw getMdSortDuplicateMdSortableIdError(sortable.id);
        }
        this.sortables.set(sortable.id, sortable);
    };
    /**
     * Unregister function to be used by the contained MdSortables. Removes the MdSortable from the
     * collection of contained MdSortables.
     * @param {?} sortable
     * @return {?}
     */
    MdSort.prototype.deregister = function (sortable) {
        this.sortables.delete(sortable.id);
    };
    /**
     * Sets the active sort id and determines the new sort direction.
     * @param {?} sortable
     * @return {?}
     */
    MdSort.prototype.sort = function (sortable) {
        if (this.active != sortable.id) {
            this.active = sortable.id;
            this.direction = sortable.start ? sortable.start : this.start;
        }
        else {
            this.direction = this.getNextSortDirection(sortable);
        }
        this.mdSortChange.next({ active: this.active, direction: this.direction });
    };
    /**
     * Returns the next sort direction of the active sortable, checking for potential overrides.
     * @param {?} sortable
     * @return {?}
     */
    MdSort.prototype.getNextSortDirection = function (sortable) {
        if (!sortable) {
            return '';
        }
        // Get the sort direction cycle with the potential sortable overrides.
        var /** @type {?} */ disableClear = sortable.disableClear != null ? sortable.disableClear : this.disableClear;
        var /** @type {?} */ sortDirectionCycle = getSortDirectionCycle(sortable.start || this.start, disableClear);
        // Get and return the next direction in the cycle
        var /** @type {?} */ nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
        if (nextDirectionIndex >= sortDirectionCycle.length) {
            nextDirectionIndex = 0;
        }
        return sortDirectionCycle[nextDirectionIndex];
    };
    return MdSort;
}());
export { MdSort };
MdSort.decorators = [
    { type: Directive, args: [{
                selector: '[mdSort], [matSort]',
            },] },
];
/**
 * @nocollapse
 */
MdSort.ctorParameters = function () { return []; };
MdSort.propDecorators = {
    'active': [{ type: Input, args: ['mdSortActive',] },],
    'start': [{ type: Input, args: ['mdSortStart',] },],
    'direction': [{ type: Input, args: ['mdSortDirection',] },],
    'disableClear': [{ type: Input, args: ['mdSortDisableClear',] },],
    '_matSortActive': [{ type: Input, args: ['matSortActive',] },],
    '_matSortStart': [{ type: Input, args: ['matSortStart',] },],
    '_matSortDirection': [{ type: Input, args: ['matSortDirection',] },],
    '_matSortDisableClear': [{ type: Input, args: ['matSortDisableClear',] },],
    'mdSortChange': [{ type: Output },],
};
function MdSort_tsickle_Closure_declarations() {
    /** @type {?} */
    MdSort.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    MdSort.ctorParameters;
    /** @type {?} */
    MdSort.propDecorators;
    /**
     * Collection of all registered sortables that this directive manages.
     * @type {?}
     */
    MdSort.prototype.sortables;
    /**
     * The id of the most recently sorted MdSortable.
     * @type {?}
     */
    MdSort.prototype.active;
    /**
     * The direction to set when an MdSortable is initially sorted.
     * May be overriden by the MdSortable's sort start.
     * @type {?}
     */
    MdSort.prototype.start;
    /**
     * The sort direction of the currently active MdSortable.
     * @type {?}
     */
    MdSort.prototype.direction;
    /** @type {?} */
    MdSort.prototype._disableClear;
    /**
     * Event emitted when the user changes either the active sort or sort direction.
     * @type {?}
     */
    MdSort.prototype.mdSortChange;
}
/**
 * Returns the sort direction cycle to use given the provided parameters of order and clear.
 * @param {?} start
 * @param {?} disableClear
 * @return {?}
 */
function getSortDirectionCycle(start, disableClear) {
    var /** @type {?} */ sortOrder = ['asc', 'desc'];
    if (start == 'desc') {
        sortOrder.reverse();
    }
    if (!disableClear) {
        sortOrder.push('');
    }
    return sortOrder;
}
//# sourceMappingURL=sort.js.map